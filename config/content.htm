<h1>About</h1>
<p>課程名稱: 協同產品設計實習 - Collaborative Product Design Practice</p>
<p>學員作業網站:<a class="Link--inTextBlock" href="https://mdecd2025.github.io/hw-41023114/">https://mdecd2025.github.io/hw-41023114/</a></p>
<p>學員作業倉儲:https://github.com/mdecd2025/hw-41023114</p>
<hr/>
<p>課程代號: cd2025</p>
<p>Teams 線上教學:</p>
<p style="padding-left: 30px;">以 "學號@nfu.edu.tw" 登入<span> </span><a href="https://login.microsoftonline.com/">https://login.microsoftonline.com/</a><span> </span>Office 365</p>
<p style="padding-left: 30px;">Teams 團隊代碼: <span>p5z4eku</span></p>
<hr/>
<p>課程評分:</p>
<p style="padding-left: 30px;">Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單</p>
<p style="padding-left: 30px;">Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單</p>
<p style="padding-left: 30px;">Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單</p>
<h2>repo</h2>
<p>tokentest</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/dKuPgrxxRBc" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/on3H-S4DW8g" width="560"></iframe></p>
<h1>Tasks</h1>
<h2>Tasks1</h2>
<p>自行製作、更新可攜程式系統</p>
<p>利用 C:\Portable_2023_fall 啟動舊版的可攜程式環境, 目的是要藉由舊版的 Python 執行 <a href="https://mdecd2025.github.io/hw-scrum-1/downloads/gen_p3132.py">gen_p3132.py</a>, 取得基本的 Python 後, 修改 start.bat, 以 Python313 啟動可攜.</p>
<p>之後利用 Python 3.13.2 在命令列執行<span> </span><a href="https://mdecd2025.github.io/hw-scrum-1/downloads/get-pip.py">get-pip.py</a>, 以便安裝 pip.exe.</p>
<p>之後利用新版的 SciTE, Portablegit, PUTTY, ShareX, Wink 以及原有的 tmp 及 home_ipv6, 以另存新的<span> start.bat</span><span> </span>啟動.</p>
<p>以下為操作影片, 影片中採用兩年前 C: 中的 Python 3.11 舊系統自製、更新為 Python 3.13.2 為主的新可攜程式環境.</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/O00C2PnaPO8" width="560"></iframe></p>
<h3>list</h3>
<p>此為2b list 以下有操作紀錄影片</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023114/ddb7e62d6da50c2e94b70bd6b6c67b66/raw/fc24defff76dd38a0f4ed0bcb411d4c2bf263b48/list4"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/41023114/ddb7e62d6da50c2e94b70bd6b6c67b66/raw/fc24defff76dd38a0f4ed0bcb411d4c2bf263b48/list4"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2PFCBBmQmso" width="560"></iframe></p>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p></p>
<h2>Tasks2</h2>
<h3>ipv6</h3>
<p>以下有操作紀錄影片</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/ipv6+number"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/ipv6+number"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/LUBZG4Enoko" width="560"></iframe></p>
<h3>w3</h3>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/teamX3"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/teamX3"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/jsjmZk-UBUw" width="560"></iframe></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>這是上課準備所需學習的借GPT輔助來編撰code以及學習如何與GPT溝通才能得到需要的答案。</p>
<h2>Tasks3</h2>
<h2>Tasks4</h2>
<h3>w6</h3>
<p>solvespace新四連桿連接</p>
<p>建造平面四連桿的尺寸設計: 固定桿長度<strong>連結圓心</strong>長為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m</p>
<p><a href="/downloads/4linkslvs.7z">4linkslvs.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ZQ5uWo83qr0" width="560"></iframe></p>
<p>在onshape中繪製圖形導入webots</p>
<p>其中繪製時要將尺寸訂為原本的10倍，如此導入後不會縮小</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JHluhnBsEN4" width="560"></iframe></p>
<p>修正後可運動結果</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/TEx45fWxmt0" width="560"></iframe></p>
<p>此為模擬檔案</p>
<p><a href="/downloads/4linkwe.7z">4linkwe.7z</a></p>
<p>從上上周理解了webot的座標關係後，到了做第二版的四連桿已經比較上手了，中間一周是在了解甚麼東西可以產生webot所需要的obj檔，因此才有上面三部影片。</p>
<h3>w4</h3>
<p><strong>建造平面四連桿的尺寸設計: 固定桿長度為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m</strong></p>
<p>1.建立robot群組</p>
<p>2.robot下的children建立1個solid群組，2個higejoint群組，並選一個為首要，命名為joint1</p>
<p>3.solid的children中建立shape作為固定桿(X1,Y0.1,Z0.1)</p>
<p>4.<span>joint1下的endpoint選擇solid性質，命名為link1，並往下的children中建立pose及higejoint，pose下在建立shape為主動桿(0.4,0.1,0.1)</span><span>，shape命名為link1，再將主動桿所屬的pose的translation設為(0.2,0,0)(此為link1中心點)，而higejoint為主動桿與第二桿連接，並命名為joint2。</span></p>
<p><span>5.joint1的endpoint下有translation(此為連接處的座標點)，設(-0.5,0,0.1)</span></p>
<p><span>6.在joint1下有boundingObject，選擇pose，往下children選擇USE link1，並調整座標至(0.2,0,0)(與link1的pose座標一致)，在設置physics</span></p>
<p>7.以上順序重複製作，主要為base--&gt;joint1--&gt;link1--&gt;<span>joint2--&gt;link2--&gt;</span><span>joint3--&gt;link3--&gt;joint4</span></p>
<p><span>8.joint4在robot群組中的children，與joint1同排列，並將endpoint設為solidreference，並選為use link3</span></p>
<p><span>9.每一階的joint中各有jointparameters、device、emdpoint，其中link1上的device要加入Rotationalmotor，並命名為motor</span></p>
<p><span>10.而每一階的jointparameters，axis設為(0,0,1)(意為繞z軸旋轉)，但anchor要設為桿的長度，這樣才是joint到joint的距離，分別為(-0.5,0,0)、(0.4,0,0)、(0.6,0,0)，此座標是接續的，原點根據base的起點，另外設置的joint4則為(0.5,0,0)</span></p>
<p><strong></strong></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/65a4Fkog1H0" width="560"></iframe></p>
<p>此為修改後的結果</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/E7of8Y-qv24" width="560"></iframe></p>
<p><span>起初操作的過程我認為十分困難，大概花了3天學習webots，光是理解各個座標存在的相應關係、原理，就十分需要下功夫，更何況這並不是借老師範本就能一次成功的作業。</span></p>
<h2>Tasks5</h2>
<h3>Blender</h3>
<p>Blender顏色更改</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/OHl5c13Icg0" width="560"></iframe></p>
<p>這是在上課時老師講解到的換色功能，在課堂中學習使用，下課後自行修改。</p>
<h3>w7</h3>
<p>在老師的<a href="https://mde.tw/cd2025/downloads/cd2025_hw1_demo.7z">cd2025_hw1_demo.7z</a>檔案中有三個split_stl_to_obj_scale的檔案，先將solvespace中四連桿機構從</p>
<p>左上的File-&gt;Export Triangle Mesh下載STL檔，並在<span>split_stl_to_obj_scale的最下面有</span></p>
<p><span><img alt="" height="120" src="/images/螢幕擷取畫面 2025-04-01 184002.png" width="347"/></span></p>
<p><span>將STL檔案輸入於上面，並將這個python檔案帶入你要轉換的資料夾中，然後再使用SciTE執行，他會產生split_parts資料夾，並自動將obj檔都整理再此資料夾中。</span></p>
<p><span>最後再將此obj檔直接導入webot中，將可不用自行訂製座標。</span></p>
<p>操作影片於<a href="https://mdecd2025.github.io/hw-41023114/content/HW2.html">HW2</a></p>
<hr/><!-- ########################################## -->
<p>solvespace basket_ball_shooter繪製</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/FxjXAogp-wk" width="560"></iframe></p>
<p><span>solvespace basket_ball_shooter組裝</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/iOeLvm_IQMg" width="560"></iframe></p>
<p>基本的四連桿都練習過後，接下來做的就是實現四連桿實用，這兩部影片最大的困難是shooter的組裝，上傳的是成功的影片，第一次組裝時應該花了下午到晚上的時間，要理解組裝方向及相對關係才能排出先平行還是先共點。</p>
<h3>w9</h3>
<p>shooter導入webot</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/v_c-pkeymm0" width="560"></iframe></p><h2>Tasks6</h2>
<h3>Tutorial1</h3>
<p><strong>Start webots</strong></p>
<p>1.啟動 Webots<br/>如果你還沒安裝 Webots，請先下載並安裝。安裝完成後，雙擊 Webots 的圖示啟動程式。第一次啟動時，可能會要求你選擇介面主題，選擇你喜歡的即可。</p>
<p>2.建立新專案<br/>點選「檔案」&gt;「新建」&gt;「新建專案目錄」，然後設定專案名稱為 my_first_simulation，並將世界檔案命名為 my_first_simulation.wbt。確保勾選「加入矩形競技場」選項，這樣就會自動建立一個包含地板和牆壁的簡單環境。</p>
<hr/><!-- ########################################## -->
<p>Create a New World</p>
<p>A World is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, and the definitions of gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called Nodes and are organized hierarchically in a Scene Tree. Therefore, a node may contain sub-nodes. A world is stored in a file having the .wbt extension. The file format is derived from the VRML97 language, and is human readable. The world files must be stored directly in a directory called worlds.</p>
<p>一個<strong data-end="29" data-start="23">世界</strong>（World）是一個檔案，包含像是物體的位置、外觀、它們如何互動、天空的顏色、以及重力、摩擦力、物體質量等定義的資訊。它定義了模擬的初始狀態。不同的物體被稱為<strong data-end="114" data-start="108">節點</strong>（Nodes），並且以<strong data-end="132" data-start="125">場景樹</strong>（Scene Tree）的階層結構組織。因此，一個節點可能包含子節點。世界檔案儲存在具有 <code data-end="183" data-start="177">.wbt</code> 副檔名的檔案中。該檔案格式源自 VRML97 語言，並且是人類可讀的。世界檔案必須直接儲存在名為 <strong data-end="243" data-start="233">worlds</strong> 的資料夾中。</p>
<p>World – 世界，這是 Webots 的基本檔案類型，定義模擬的初始狀態。</p>
<p>File – 檔案，這裡指的是儲存世界資訊的檔案。</p>
<p>Objects – 物體，Webots 中的模擬物件。</p>
<p>Interact with – 互動，指的是物體之間的交互行為。</p>
<p>Color of the sky – 天空顏色，環境的一部分，通常會在背景設定中修改。</p>
<p>Gravity – 重力，物理參數之一。</p>
<p>Friction – 摩擦力，物理參數之一。</p>
<p>Masses – 質量，物理參數之一。</p>
<p>Nodes – 節點，Webots 中的基本物件，可以包含其他物件（子節點）。</p>
<p>Scene Tree – 場景樹，將節點按照層次結構組織的方式。</p>
<p>Sub-nodes – 子節點，節點下層的結構。</p>
<p>.wbt extension – .wbt 副檔名，Webots 世界檔的格式。</p>
<p>VRML97 – 一種三維虛擬現實建模語言，Webots 世界檔格式來源。</p>
<p>Human readable – 人類可讀，表示該檔案格式容易理解。</p>
<p></p>
<p>1.A is B that...</p>
<p>用來解釋 A 是 B 且 B 是什麼，這是一個常見的定義句型。</p>
<p>例句：</p>
<p>"A World is a file containing information like..."<br/>→ 「世界是一個包含以下資訊的檔案……」</p>
<p>2.like</p>
<p>用來舉例或列出類似的事物。</p>
<p>例句：</p>
<p>"...information like where the objects are, what they look like..."<br/>→ 「像是物體的位置、外觀等資訊」</p>
<p>3.and</p>
<p>用來連接詞語或句子中的多個項目。</p>
<p>例句：</p>
<p>"...the color of the sky, and the definitions of gravity, friction..."<br/>→ 「天空顏色，還有重力、摩擦力的定義」</p>
<p>4.Therefore</p>
<p>表示因果關係，通常用來引出結論。</p>
<p>例句：</p>
<p>"Therefore, a node may contain sub-nodes."<br/>→ 「因此，一個節點可能包含子節點。」</p>
<p>5.may</p>
<p>表示可能性，用來描述不確定的情況。</p>
<p>例句：</p>
<p>"A node may contain sub-nodes."<br/>→ 「一個節點可能會包含子節點。」</p>
<p>6.having</p>
<p>用來描述具有某種特徵的事物。</p>
<p>例句：</p>
<p>"A world is stored in a file having the .wbt extension."<br/>→ 「世界檔案是儲存在具有 .wbt 副檔名的檔案中。」</p>
<p>7.derived from</p>
<p>表示某事物來源於或基於某個東西。</p>
<p>例句：</p>
<p>"The file format is derived from the VRML97 language."<br/>→ 「檔案格式來源於 VRML97 語言。」</p>
<p>8.must be</p>
<p>用來強調必須做某事，是義務或要求。</p>
<p>例句：</p>
<p>"The world files must be stored directly in a directory called worlds."<br/>→ 「世界檔案必須直接儲存在名為 worlds 的資料夾中。」</p>
<p>主要是在講解場地</p>
<p>調整地板和牆壁大小<br/>在「場景樹」中選擇 RectangleArena，然後調整以下參數：</p>
<p>floorTileSize：改為 0.25 0.25，讓地板磚塊變小。</p>
<p>wallHeight：改為 0.05，讓牆壁變矮。</p>
<p>加入木箱<br/>點選「新增」按鈕，選擇 PROTO nodes (Webots Projects) / objects / factory / containers / WoodenBox (Solid)，在競技場中間會出現一個大箱子。選擇這個箱子，然後調整以下參數：</p>
<p>size：改為 0.1 0.1 0.1，讓箱子變小。</p>
<p>translation：改為 0 0 0.05，讓箱子稍微浮起。</p>
<p>接著，使用複製貼上（Ctrl+C 和 Ctrl+V）來新增兩個箱子，並將它們移動到競技場的不同位置，避免它們都集中在中間。</p>
<hr/><!-- ########################################## -->
<p><strong>Add an e-puck Robot</strong></p>
<p>The e-puck is a small robot having differential wheels, 10 LEDs, and several sensors including 8 DistanceSensors and a Camera. In this tutorial we are only interested in using its wheels.</p>
<p>e-puck 是一個小型機器人，擁有差速輪、10 顆 LED 燈和幾個感測器，包括 8 顆距離感測器和一個相機。在本教程中，我們只會關注它的輪子。我們會在接下來的教程中學習如何使用其他功能。</p>
<p>主要在講解e-puck機器人</p>
<p>加入 e-puck 機器人<br/>點選「新增」按鈕，選擇 PROTO nodes (Webots Projects) / robots / mobile / e-puck，這樣就會在競技場中加入一台 e-puck 機器人。</p>
<p>設定機器人控制程式<br/>在「場景樹」中選擇 e-puck，然後在 controller 欄位中輸入控制程式的名稱，例如 my_controller。這樣，當我們建立控制程式時，機器人就會使用它來控制行為。</p>
<p></p>
<p>e-puck - 小型機器人，這是 Webots 中的預設機器人之一。</p>
<p>differential wheels - 差速輪，兩個輪子的轉速差控制機器人的移動。</p>
<p>LEDs - 發光二極管，這裡指的是機器人上的燈。</p>
<p>DistanceSensors - 距離感測器，用來測量機器人與物體的距離。</p>
<p>PROTO node - 一種 Webots 節點，用來創建可重用的自定義物件。</p>
<p>Scene Tree - 場景樹，Webots 的節點組織結構。</p>
<p>real-time - 即時模擬模式。</p>
<p>mass - 質量，物體的物理屬性之一。</p>
<p>basicTimeStep - 基本時間步長，用於控制物理模擬的步伐。</p>
<p>reset - 重置，將模擬恢復到初始狀態。</p>
<p>simulation - 模擬，指在 Webots 中執行的虛擬環境。</p>
<p>apply a force - 施加力，用於操控物體的移動。</p>
<p>ctrl key - 控制鍵，用於進行某些操作的快捷鍵。</p>
<hr/><!-- ########################################## -->
<p data-pm-slice="1 1 []"><strong>Create a New Controller</strong></p>
<p>We will now program a simple controller that will just make the robot move forwards. A controller is a program that defines the behavior of a robot. Webots controllers can be written in the following programming languages: C, C++, Java, Python, MATLAB, etc. C, C++ and Java controllers need to be compiled before they can be run as robot controllers. Python and MATLAB controllers are interpreted languages so they will run without being compiled. In this tutorial, we are going to use C as a reference language but all the code snippets are also available in C++, Java, Python and MATLAB. Refer to the language chapter to setup a controller using a different programming language.</p>
<p>The controller field of a Robot node specifies which controller is currently associated to the robot. Note that the same controller can be used by several robots, but a robot can only use one controller at a time. Each controller is executed in a separate child process usually spawned by Webots. Because they are independent processes, controllers don't share the same address space, and may run on different processor cores.</p>
<p class="" data-end="273" data-start="42">控制器是一個程式，用來定義機器人的行為。Webots 控制器可以使用以下程式語言編寫：C、C++、Java、Python、MATLAB 等。C、C++ 和 Java 控制器需要編譯後才能作為機器人控制器運行，而 Python 和 MATLAB 控制器是直譯語言，因此不需要編譯就可以運行。在本教程中，我們將使用 C 作為參考語言，但所有的程式碼片段也會提供 C++、Java、Python 和 MATLAB 版本。若要使用其他程式語言設置控制器，請參閱語言章節。</p>
<p class="" data-end="443" data-start="275">機器人節點（Robot node）的控制器欄位指定了當前與機器人相關聯的控制器。請注意，同一個控制器可以被多個機器人使用，但每次只有一個機器人可以使用同一個控制器。每個控制器都是在一個單獨的子進程中執行，這些子進程通常是由 Webots 啟動的。由於它們是獨立的進程，控制器之間不共享相同的地址空間，並且可能會在不同的處理器核心上運行。</p>
<p>Controller - 控制器：定義機器人行為的程式。</p>
<p>Robot node - 機器人節點：Webots 中的一個節點，代表機器人本身。</p>
<p>Program - 程式：計算機執行的指令集，這裡指的是控制機器人行為的程式。</p>
<p>Compiled - 編譯：將程式碼轉換為機器能執行的格式。</p>
<p>Interpreted - 直譯：程式碼不需要編譯，而是由解釋器直接執行。</p>
<p>Language - 語言：指程式語言，這裡提到 C、C++、Java、Python 和 MATLAB。</p>
<p>Independent processes - 獨立進程：指每個控制器在不同的進程中運行，互不影響。</p>
<p>Address space - 地址空間：記憶體中用來儲存程序和資料的區域。</p>
<p>Processor cores - 處理器核心：處理器中的獨立運算單元。</p>
<p></p>
<p>1.We will now - 用來表示即將進行的動作，語氣較為強調未來行動。</p>
<p>例句：We will now program a simple controller.</p>
<p>2.that will - 用來表示目的或未來的動作。</p>
<p>例句：We will now program a simple controller that will just make the robot move forwards.</p>
<p>3.A controller is a program that - 定義和解釋某事物的結構，這裡是對「控制器」的解釋。</p>
<p>例句：A controller is a program that defines the behavior of a robot.</p>
<p>4.can be written in - 表示某事物可以以某種方式來做，這裡用於說明控制器的語言選擇。</p>
<p>例句：Webots controllers can be written in the following programming languages.</p>
<p>5.may run - 表示可能發生的狀況或行為。</p>
<p>例句：...and may run on different processor cores.</p>
<p>6.is executed in - 描述某事物的運行或執行方式。</p>
<p>例句：Each controller is executed in a separate child process usually spawned by Webots.</p>
<p>7.Refer to - 用來表示參考某資料或章節。</p>
<p>例句：Refer to the language chapter to setup a controller using a different programming language.</p>
<p></p>
<p>主要在講解建立控制程式<br/>在 Webots 中，控制程式是用來定義機器人行為的程式。你可以使用 Python、C、C++、Java 等語言來撰寫控制程式。這裡我們以 Python 為例。</p>
<p>撰寫簡單的前進程式<br/>在 Webots 的控制程式資料夾中，建立一個新的 Python 檔案，命名為 my_controller.py，並輸入以下程式碼：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot, Motor

TIME_STEP = 64
MAX_SPEED = 6.28

robot = Robot()

leftMotor = robot.getMotor('left wheel motor')
rightMotor = robot.getMotor('right wheel motor')

leftMotor.setPosition(float('inf'))
rightMotor.setPosition(float('inf'))

leftMotor.setVelocity(0.1 * MAX_SPEED)
rightMotor.setVelocity(0.1 * MAX_SPEED)

while robot.step(TIME_STEP) != -1:
    pass
</pre>
<p><br/><br/></p>
<hr/><!-- ########################################## -->
<p></p>
<h3>Tutorial2</h3>
<p>在本教學中，我們將學習如何在環境中建立簡單的物件。第一步是建立一顆會與環境互動的球體。我們將探討與節點相關的多個概念：它們的意義、如何建立、如何關聯等。此外，我們還將了解如何設定物理屬性。</p>
<p>將介紹幾種類型的節點。它們的詳細定義可以在參考手冊中找到。擁有節點圖表將有助於理解節點之間的繼承關係。</p>
<hr/><!-- ########################################## -->
<p><strong>The Solid Node</strong></p>
<p>The Solid Node<br/>This subsection introduces the most important base node in Webots: the Solid node, from which many other nodes derive.</p>
<p>A Solid node represents a rigid body, that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies.</p>
<p>The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies.</p>
<p>To define a rigid body, you will have to create a Solid node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following figure depicts a rigid body and its sub-nodes. The graphical representation of the Solid node is defined by the Shape nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p>這一小節介紹了 Webots 中最重要的基礎節點：<strong>Solid 節點</strong>，許多其他節點都是從它衍生出來的。</p>
<p>Solid 節點代表一個剛體，也就是一種在模擬中可以忽略變形的物體。剛體中任意兩點之間的距離在時間中是保持不變的，即使有外力施加在上面也是如此。例如：桌子、機器人的指節、或是輪子，這些都是剛體。而軟體（soft bodies）或具有關節的物體則不屬於剛體，比如繩子、輪胎、海綿，或是關節式的機器人手臂就不是剛體。不過，一個有關節的物體可以拆解成數個剛體來處理。</p>
<p>Webots 的物理引擎專門用來<strong>模擬剛體</strong>。因此，在設計模擬時，一個重要的步驟就是把各個物件拆解成獨立的剛體。</p>
<p>若要定義一個剛體，你需要建立一個 Solid 節點。在這個節點中，你將設定一些子節點來描述這個剛體的特性。下圖展示了一個剛體及其子節點的結構：</p>
<p><strong>圖形外觀</strong>（Graphical representation） 是由放在 children 清單中的 Shape 節點 來定義的。</p>
<p><strong>碰撞邊界</strong>（Collision bounds） 則是由 boundingObject 欄位來設定。</p>
<p>通常圖形外觀與碰撞形狀是一樣的，但不一定非得相同。</p>
<p>最後，physics 欄位會決定這個物件是屬於<strong>動態物件</strong>還是<strong>靜態環境</strong>的一部分。</p>
<p>所有這些子節點都是可選的，但若要使用 physics 欄位，<strong>就必須定義</strong> boundingObject。</p>
<p><img alt="" height="245" src="/images/螢幕擷取畫面 2025-04-16 220900.png" width="300"/></p>
<p>Solid node Solid 節點、剛體節點 Webots 中用來定義剛體的節點<br/>Rigid body 剛體 一種不會變形的物體<br/>Deformation 變形 通常是物體在受力後的形狀改變<br/>External force 外力 來自外部施加在物體上的力量<br/>Soft body 軟體 可以變形的物體<br/>Articulated object 關節式物體 有連接部位、可活動的物體<br/>Physics engine 物理引擎 模擬物理行為的程式模組<br/>Simulation 模擬 在電腦中模擬現實情境<br/>Sub-node 子節點 階層式結構中的下層節點<br/>Graphical representation 圖形表示 在 3D 視圖中可看到的外觀<br/>Collision bounds 碰撞邊界 用於物理計算的碰撞區域<br/>boundingObject 邊界物件欄位 定義碰撞邊界用的欄位<br/>children list 子節點清單 包含 Shape 等節點的集合<br/>Shape node 形狀節點 描述物體圖形的節點<br/>physics field 物理欄位 決定是否加入動力模擬<br/>dynamical/static environment 動態/靜態環境 是否會移動（物理互動）的物體</p>
<p></p>
<p>1.This subsection introduces...</p>
<p>用來開始段落、介紹某主題。</p>
<p>例句：This subsection introduces the most important base node in Webots.</p>
<p>翻譯：這一小節介紹了 Webots 中最重要的基礎節點。</p>
<p>2.A Solid node represents...</p>
<p>主詞 + 動詞 + 補語 → 用來定義或說明某事物的功能。</p>
<p>例句：A Solid node represents a rigid body.</p>
<p>翻譯：Solid 節點代表一個剛體。</p>
<p>3.can be broken into...</p>
<p>被動語態 + break into，表示可被分成...</p>
<p>例句：An articulated entity can be broken into several rigid bodies.</p>
<p>翻譯：關節式物體可以被分成多個剛體。</p>
<p>4.You will have to...</p>
<p>未來式 + have to，表示「你必須」。</p>
<p>例句：You will have to create a Solid node.</p>
<p>翻譯：你將需要建立一個 Solid 節點。</p>
<p>5....defined by...</p>
<p>表示由...定義、構成。</p>
<p>例句：The graphical representation is defined by the Shape nodes...</p>
<p>翻譯：圖形表示是由 Shape 節點定義的。</p>
<p>6....but not necessarily...</p>
<p>表示「但不一定是…」</p>
<p>例句：...are often but not necessarily identical.</p>
<p>翻譯：通常是相同的，但不一定。</p>
<p>7.All these sub-nodes are optional, but...</p>
<p>對比句型，用來表達例外或限制。</p>
<p>例句：All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p>翻譯：這些子節點都是可選的，但若要使用 physics 欄位，就必須定義 boundingObject。</p>
<p></p>
<p>主要在講解</p>
<p>Solid 節點是 Webots 中最重要的基礎節點之一，代表一個剛體物件。它包含以下子節點：</p>
<p>Shape：定義物件的外觀。</p>
<p>boundingObject：定義物件的碰撞邊界。</p>
<p>physics：定義物件的物理屬性。</p>
<p>這些子節點是可選的，但如果要讓物件具有物理屬性，必須定義 boundingObject 和 physics。</p>
<hr/><!-- ########################################## -->
<p><strong>Create a Ball</strong></p>
<p>We will now add a ball to the simulation. That ball will be modeled as a rigid body as shown in this figure. A Sphere node will be used to define the geometry of our ball.</p>
<p>Hands-on #4: In the scene tree view, select the last node and press the Add button. In the dialog, open the Bases nodes section and select the Solid node. In the scene tree view, expand the Solid node and select its children field. Add a Shape node to it by using the Add button. Select the appearance field of the Shape node and use the Add button to add a PBRAppearance node.</p>
<p>1.Add a Sphere node as the geometry field of the newly created Shape node.<br/>2.Expand the PBRAppearance node and change its metalness field to 0 and its roughness field to 1.<br/>3.Add another Sphere node to the boundingObject field of the Solid.<br/>4.Finally add a Physics node to the physics field of the Solid.<br/>5.By modifying the translation field of the Solid node, place the ball in front of the robot (at {0.2, 0, 0.2} for example).<br/>6.Save the simulation.<br/>7.The result is depicted in this figure.</p>
<p>When the simulation is started, the ball hits the floor. You can move the ball by applying a force to it (ctrl + alt + left-click + drag). The contact points between the ball and the floor can be displayed as cyan lines by enabling the View / Optional Rendering / Show Contact Points menu item.</p>
<p class="" data-end="142" data-start="74">我們現在要在模擬中加入一顆球。這顆球將會被建模為一個<strong data-end="106" data-start="100">剛體</strong>，如下圖所示。我們將使用 <code data-end="127" data-start="119">Sphere</code> 節點來定義這顆球的幾何形狀。</p>
<p class="" data-end="388" data-start="144"><strong data-end="154" data-start="144">實作 #4：</strong><br data-end="157" data-start="154"/> 在 <strong data-end="168" data-start="159">場景樹視圖</strong> 中，選取最後一個節點並按下 <strong data-end="189" data-start="183">新增</strong> 按鈕。在跳出的對話框中，展開 <strong data-end="220" data-start="205">Bases nodes</strong> 區段，然後選擇 <strong data-end="238" data-start="229">Solid</strong> 節點。<br data-end="245" data-start="242"/> 在場景樹視圖中展開這個 Solid 節點，並選取它的 <code data-end="282" data-start="272">children</code> 欄位。接著，按下 <strong data-end="298" data-start="292">新增</strong> 按鈕加入一個 <strong data-end="315" data-start="306">Shape</strong> 節點。<br data-end="322" data-start="319"/> 再選取剛加入的 Shape 節點的 <code data-end="352" data-start="340">appearance</code> 欄位，使用新增按鈕加入一個 <strong data-end="384" data-start="367">PBRAppearance</strong> 節點。</p>
<p class="" data-end="618" data-start="390">在 Shape 節點的 <code data-end="412" data-start="402">geometry</code> 欄位加入一個 <strong data-end="430" data-start="420">Sphere</strong> 節點，作為球的幾何外觀。<br data-end="446" data-start="443"/> 展開 PBRAppearance 節點，將 <code data-end="479" data-start="468">metalness</code> 欄位改為 <strong data-end="490" data-start="485">0</strong>，<code data-end="502" data-start="491">roughness</code> 欄位改為 <strong data-end="513" data-start="508">1</strong>。<br data-end="517" data-start="514"/> 在 Solid 節點的 <code data-end="545" data-start="529">boundingObject</code> 欄位中再加入一個 <strong data-end="565" data-start="555">Sphere</strong> 節點，用來定義碰撞邊界。<br data-end="581" data-start="578"/> 最後，在 <code data-end="595" data-start="586">physics</code> 欄位加入一個 <strong data-end="614" data-start="603">Physics</strong> 節點。</p>
<p class="" data-end="697" data-start="620">透過修改 Solid 節點的 <code data-end="648" data-start="635">translation</code> 欄位，把球放在機器人前面的位置（例如設為 <code data-end="685" data-start="670">{0.2, 0, 0.2}</code>）。<br data-end="690" data-start="687"/> 儲存這個模擬。</p>
<p class="" data-end="756" data-start="699">這是你在 Webots 中建立的第一個剛體。</p>
<p class="" data-end="905" data-start="758">當你開始模擬後，球會落到地板上。你可以透過施加力來移動這顆球（按住 <code data-end="811" data-start="792">Ctrl + Alt + 左鍵拖曳</code>）。<br data-end="816" data-start="813"/> 若你想查看球與地面接觸的點，可以從功能表中點選：<strong data-end="891" data-start="840">View &gt; Optional Rendering &gt; Show Contact Points</strong>，就會以青綠色線條顯示出來。</p>
<p class="" data-end="905" data-start="758"></p>
<p class="" data-end="905" data-start="758">Ball 球體 模擬中新增的物件<br/>Rigid body 剛體 不會變形的物體，適合用於物理模擬<br/>Solid node Solid 節點 Webots 中用來定義剛體的節點<br/>Sphere node 球形節點 幾何形狀為球的節點<br/>Shape node 外觀節點 定義圖形外觀<br/>PBRAppearance node 實體外觀節點 用於設定金屬感、粗糙度等外觀屬性<br/>boundingObject 邊界物件欄位 用來定義物理碰撞用的區域<br/>Physics node 物理屬性節點 控制物體是否受重力、摩擦等影響<br/>translation 位移欄位 設定物體在空間中的位置<br/>metalness 金屬感 外觀參數，0 表示非金屬<br/>roughness 粗糙度 外觀參數，1 表示完全粗糙<br/>Apply a force 施加力量 移動物體的方式之一<br/>Contact point 接觸點 物體接觸地面時產生的物理點</p>
<p class="" data-end="905" data-start="758"></p>
<p>1.We will now add...</p>
<p>表示即將執行的操作。</p>
<p>例句：We will now add a ball to the simulation.</p>
<p>翻譯：我們現在要在模擬中加入一顆球。</p>
<p>2.That ball will be modeled as...</p>
<p>被動語態 + as，用於描述物件如何被建模。</p>
<p>例句：That ball will be modeled as a rigid body.</p>
<p>翻譯：這顆球會被建模成一個剛體。</p>
<p>3.Select the ... and press the Add button.</p>
<p>指令句型，常見於操作教學中。</p>
<p>例句：Select the last node and press the Add button.</p>
<p>翻譯：選取最後一個節點並按下新增按鈕。</p>
<p>4.Expand ... and change its ... field to ...</p>
<p>表示進入某節點並修改其欄位。</p>
<p>例句：Expand the PBRAppearance node and change its metalness field to 0.</p>
<p>翻譯：展開 PBRAppearance 節點，將 metalness 欄位設為 0。</p>
<p>5.The result is depicted in this figure.</p>
<p>被動語態，用於說明結果已被圖示。</p>
<p>例句：The result is depicted in this figure.</p>
<p>翻譯：結果如下圖所示。</p>
<p>6.You can move the ball by...</p>
<p>by + V-ing，表示透過某動作達成某目的。</p>
<p>例句：You can move the ball by applying a force to it.</p>
<p>翻譯：你可以透過施加力量來移動這顆球。</p>
<p>7.can be displayed by enabling...</p>
<p>被動語態 + by V-ing，表示可以透過某操作來達成。</p>
<p>例句：The contact points can be displayed by enabling the View menu...</p>
<p>翻譯：接觸點可以透過啟用 View 選單來顯示。</p>
<p></p>
<p>主要在講解如何建立球體</p>
<p><strong>1.新增 Solid 節點</strong><br/>在場景樹中選擇最後一個節點，點擊「新增」按鈕，選擇 Base nodes 中的 Solid 節點。</p>
<p><strong>2.新增 Shape 節點</strong><br/>展開 Solid 節點，選擇 children 欄位，點擊「新增」按鈕，選擇 Shape 節點。</p>
<p><strong>3.設定外觀</strong><br/>展開 Shape 節點，選擇 appearance 欄位，點擊「新增」按鈕，選擇 PBRAppearance 節點。將 metalness 設為 0，roughness 設為 1。</p>
<p><strong>4.設定幾何形狀</strong><br/>在 Shape 節點中，選擇 geometry 欄位，點擊「新增」按鈕，選擇 Sphere 節點。將 radius 設為 0.05，subdivision 設為 2。</p>
<p><strong>5.設定碰撞邊界</strong><br/>在 Solid 節點中，選擇 boundingObject 欄位，點擊「新增」按鈕，選擇 Sphere 節點。將 radius 設為 0.05，subdivision 設為 2。</p>
<p><strong>6.設定物理屬性</strong><br/>在 Solid 節點中，選擇 physics 欄位，點擊「新增」按鈕，選擇 Physics 節點。</p>
<p><strong>7.設定位置</strong><br/>在 Solid 節點中，選擇 translation 欄位，將其值設定為 {0.2, 0, 0.2}，將球體放置在機器人前方。</p>
<p><strong>8.儲存模擬</strong><br/>完成上述步驟後，儲存模擬檔案。</p>
<hr/><!-- ########################################## -->
<p><strong>Geometries</strong></p>
<p>To define the ball, we used the Sphere node in two different contexts: for the graphical representation (children) and to define the physical bounds (boundingObject). All Geometry nodes (such as the Sphere node) can be used in a graphical context. However, only a subset of them can be used in a physical context. The nodes chart diagram indicates which nodes are supported in each context.</p>
<p>We are now going to reduce the size of the Sphere and increase its graphical quality by increasing the number of triangles used to represent it.</p>
<p>Hands-on #5: For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for.</p>
<p>為了定義這顆球，我們在兩種不同的情境中使用了 Sphere（球體）節點：<br/>一是在圖形呈現（children）中，另一個則是用來定義物理邊界（boundingObject）。<br/>所有的幾何節點（像是 Sphere）都可以用在圖形呈現的情境中。<br/>然而，只有其中一部分的幾何節點可以用在物理模擬的情境中。<br/>你可以參考節點圖（nodes chart diagram），來確認每個節點在哪些情境中是被支援的。</p>
<p>接下來我們要縮小球的大小，並且提升圖形品質，方法是增加用來呈現球體的三角形數量。</p>
<p><strong>實作#5</strong></p>
<p>對每一個定義球體的 Sphere 節點，將：</p>
<p>radius 欄位設為 0.05，</p>
<p>subdivision 欄位設為 2。</p>
<p>若想進一步了解 subdivision 欄位的用途，可以參考官方的 Reference Manual（參考手冊）。</p>
<p></p>
<p>Geometry 幾何形狀 通常用來定義 3D 物件的外觀<br/>Sphere node 球體節點 幾何節點之一，用來建立球形物件<br/>Graphical representation 圖形呈現 指物體在 3D 視窗中看到的樣子<br/>BoundingObject 邊界物件 物體的碰撞範圍，為物理模擬用<br/>Physical context 物理情境 用於碰撞、重量、力等模擬計算<br/>Subset 子集合、部分 指從一大類中選出的某幾個<br/>Reduce 減少、降低 常用於尺寸、數量等<br/>Subdivision 分割數、細分數 決定幾何圖形的精細度（三角形數）<br/>Radius 半徑 控制球體的大小<br/>Reference Manual 參考手冊 官方說明文件</p>
<p></p>
<p>1.We used the Sphere node in two different contexts.</p>
<p>表示「我們在兩種不同情境下使用了 Sphere 節點」。</p>
<p>in [情境] context 是很實用的寫法！</p>
<p>例句翻譯：我們在兩種不同的情境中使用了 Sphere 節點。</p>
<p>2.All Geometry nodes can be used in a graphical context.</p>
<p>can be used：被動語態，表示「可以被使用」。</p>
<p>例句翻譯：所有幾何節點都可以用在圖形呈現中。</p>
<p>3.Only a subset of them can be used in a physical context.</p>
<p>only a subset of：只有其中的一部分。</p>
<p>例句翻譯：它們當中只有一部分可以用在物理情境中。</p>
<p>4.We are now going to reduce the size of the Sphere.</p>
<p>be going to + V：表示未來打算做某事。</p>
<p>例句翻譯：我們現在要來縮小球體的大小。</p>
<p>5.Increase its graphical quality by increasing the number of triangles.</p>
<p>by V-ing：藉由做某事來達成目的。</p>
<p>例句翻譯：透過增加三角形數量來提升圖形品質。</p>
<p>6.Set its radius field to 0.05 and its subdivision field to 2.</p>
<p>指令句常用語法，常見於操作說明中。</p>
<p>例句翻譯：將半徑欄位設為 0.05、細分欄位設為 2。</p>
<p></p>
<hr/><!-- ########################################## -->
<p><strong>DEF-USE Mechanism</strong></p>
<p>The DEF-USE mechanism allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node.</p>
<p>The two Sphere definitions that we have used earlier to define the ball, are redundant. We will now merge these two Spheres into only once using the DEF-USE mechanism.</p>
<p>Hands-on #6: Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string.</p>
<p>Enter BALL_GEOMETRY in this field.<br/>Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up.<br/>Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box.<br/>The result is shown in this figure.<br/>Now, changing the radius field of the first Sphere node also modifies its boundingObject.</p>
<p>For convenience, the boundingObject field also accepts the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure. For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors.</p>
<p>DEF-USE 機制可以讓你在場景樹中的某一處定義一個節點，然後在其他地方重複使用這個定義。<br/>這個機制的好處是可以避免在 world 檔中重複建立相同的節點，而且也能同時修改多個使用相同定義的物件。</p>
<p>它的運作方式如下：</p>
<p>1.先使用 DEF 關鍵字替一個節點取一個名稱。</p>
<p>2.接著，在其他位置可以使用 USE 關鍵字來引用這個節點。</p>
<p>3.<strong>只有被 DEF 定義的節點的欄位可以被修改</strong>，USE 的節點會繼承 DEF 的設定，不能獨立編輯。</p>
<p>4.這個機制依賴 world 檔中的節點順序：必須先定義 DEF 節點，才能在後面使用對應的 USE 節點。</p>
<p>我們之前為球體使用了兩個 Sphere 定義，這是重複的。<br/>現在我們要用 DEF-USE 機制，合併成一個 Sphere 節點來重複使用。</p>
<p>實作#6</p>
<ol data-end="739" data-start="507">
<li class="" data-end="548" data-start="507">
<p class="" data-end="548" data-start="510">在場景樹中，選取第一個 <code data-end="530" data-start="522">Sphere</code> 節點（<code data-end="541" data-start="534">Shape</code> 的子節點）。</p>
</li>
<li class="" data-end="593" data-start="549">
<p class="" data-end="593" data-start="552">在欄位編輯器中輸入 <code data-end="567" data-start="562">DEF</code> 名稱 → <strong data-end="592" data-start="573"><code data-end="590" data-start="575">BALL_GEOMETRY</code></strong>。</p>
</li>
<li class="" data-end="669" data-start="594">
<p class="" data-end="642" data-start="597">選取 <code data-end="616" data-start="600">boundingObject</code> 欄位（裡面原本有第二個 <code data-end="637" data-start="629">Sphere</code> 節點）：</p>
<p class="" data-end="669" data-start="648">   右鍵 → 選擇「Delete」來清空內容。</p>
</li>
<li class="" data-end="739" data-start="670">
<p class="" data-end="739" data-start="673">再次選取 <code data-end="694" data-start="678">boundingObject</code> 欄位 → 按 <strong data-end="709" data-start="702">Add</strong> → 選擇 <strong>USE / BALL_GEOMETRY。</strong></p>
</li>
</ol>
<p class="" data-end="838" data-start="741">如圖所示，現在只用一個 Sphere 就能同時定義圖形外觀和碰撞邊界。<br data-end="779" data-start="776"/> <strong data-end="838" data-start="779">當你改變第一個 Sphere 的 <code data-end="806" data-start="798">radius</code> 時，它的 <code data-end="828" data-start="812">boundingObject</code> 也會跟著改變。</strong></p>
<p class="" data-end="949" data-start="840">另外，為了方便起見，<code data-end="866" data-start="850">boundingObject</code> 欄位其實也可以接受整個 <code data-end="886" data-start="879">Shape</code> 節點（不只限於 <code data-end="903" data-start="895">Sphere</code>）。<br data-end="908" data-start="905"/> 因此也可以將整個 <code data-end="924" data-start="917">Shape</code> 節點用 <code data-end="938" data-start="929">DEF-USE</code> 重複使用，如圖所示。</p>
<p class="" data-end="1022" data-start="951">目前這樣做最大的好處是可以直接把這個 <code data-end="977" data-start="970">Shape</code> 用來做圖形呈現，<br data-end="989" data-start="986"/> 以後我們在設定感測器（sensor）時，也會發現這個機制非常實用。</p>
<p class="" data-end="1022" data-start="951"></p>
<p class="" data-end="1022" data-start="951">DEF-USE mechanism 定義與重複使用的機制 Webots 中節點重用的重要工具<br/>Scene tree 場景樹 所有節點階層結構的視覺呈現<br/>Node 節點 Webots 中的基本建構單元<br/>Field editor 欄位編輯器 可編輯節點屬性的地方<br/>BoundingObject 碰撞邊界物件欄位 定義物理碰撞區域<br/>Graphical representation 圖形呈現 物體在 3D 視圖中所呈現的外觀<br/>Context menu 快速選單、右鍵選單 使用者右鍵點擊時出現的功能選單<br/>Convenience 便利性、方便性 在說明某功能使用上較為方便時常見用詞<br/>Inherit 繼承 指 USE 會繼承 DEF 的屬性設定</p>
<p class="" data-end="1022" data-start="951"></p>
<p>1.The DEF-USE mechanism allows [動詞片語]</p>
<p>表示「這個機制可以讓你做…」</p>
<p>The DEF-USE mechanism allows to define a node…</p>
<p>DEF-USE 機制可以讓你定義節點…</p>
<p>2.Only the fields of the DEF node can be edited.</p>
<p>被動語態 + 限定詞 only，常見於規則說明。</p>
<p>Only the fields of the DEF node can be edited.</p>
<p>只有 DEF 節點的欄位可以被修改。</p>
<p>3.The fields of the USE inherit from the DEF node.</p>
<p>簡潔地表達繼承關係，用於物件導向、資料繼承等情境。</p>
<p>The fields of the USE inherit from the DEF node.</p>
<p>USE 的欄位會繼承 DEF 的設定。</p>
<p>4.A DEF node should be defined before any corresponding USE node.</p>
<p>should be + 過去分詞：表示應該要做某事的被動句型。</p>
<p>A DEF node should be defined before any corresponding USE node.</p>
<p>DEF 節點應該要在對應的 USE 節點之前定義好。</p>
<p>5.Now, changing the radius field... also modifies its boundingObject.</p>
<p>Now, + V-ing：現在做某事會產生什麼結果。</p>
<p>Now, changing the radius field also modifies its boundingObject.</p>
<p>現在，改變半徑也會同時改變碰撞邊界。</p>
<p></p>
<p>主要在講解DEF-USE機制</p>
<p class="" data-end="1650" data-start="1623">為了減少節點重複，我們可以使用 DEF-USE 機制。</p>
<ol data-end="1880" data-start="1652">
<li class="" data-end="1760" data-start="1652">
<p class="" data-end="1760" data-start="1655"><strong data-end="1668" data-start="1655">設定 DEF 標籤</strong><br data-end="1671" data-start="1668"/> 在場景樹中，選擇 <code data-end="1690" data-start="1683">Shape</code> 節點，展開它，找到 <code data-end="1711" data-start="1701">geometry</code> 欄位，選擇 <code data-end="1726" data-start="1718">Sphere</code> 節點，將 <code data-end="1737" data-start="1732">DEF</code> 欄位設定為 <code data-end="1759" data-start="1744">BALL_GEOMETRY</code>。</p>
</li>
<li class="" data-end="1880" data-start="1762">
<p class="" data-end="1880" data-start="1765"><strong data-end="1778" data-start="1765">使用 USE 標籤</strong><br data-end="1781" data-start="1778"/> 在場景樹中，選擇 <code data-end="1800" data-start="1793">Solid</code> 節點，展開它，找到 <code data-end="1827" data-start="1811">boundingObject</code> 欄位，右鍵點擊，選擇「刪除」。然後，點擊「新增」按鈕，選擇 <code data-end="1879" data-start="1858">USE / BALL_GEOMETRY</code>。</p>
</li>
</ol>
<p class="" data-end="1948" data-start="1882">這樣，當你修改 <code data-end="1905" data-start="1890">BALL_GEOMETRY</code> 的屬性時，所有使用 <code data-end="1937" data-start="1916">USE / BALL_GEOMETRY</code> 的節點都會同步更新。</p>
<hr/><!-- ########################################## -->
<p></p>
<h3>Tutorial3</h3>
<h1>Homework</h1>
<p>作業 (30%)</p>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">part1:</p>
<p style="padding-left: 60px;">請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置:</p>
<p style="padding-left: 90px;">下載 <a href="http://229.cycu.org/portable_wcm2025.7z">portable_wcm2025.7z</a> (330MB, 解開壓縮後 1.4GB)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a.7z">Webots_2025a.7z</a> (1.5 GB, 解開後約為 2.9GB, 可單獨運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a_web.7z">Webots_2025a_web.7z</a> (171 MB, 解開壓縮後約為 1GB, 必須連網運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Blender4.2.7z">Blender4.2.7z</a></p>
<p style="padding-left: 30px;">part2:</p>
<p style="padding-left: 60px;">請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 60px;">base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec.</p>
<p style="padding-left: 30px;">part3:</p>
<p style="padding-left: 60px;">模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/cd2025_hw1_demo.7z">cd2025_hw1_demo.7z</a></p>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/fourbar_slvs.7z">fourbar_slvs.7z</a></p>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p style="padding-left: 30px;">請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 (<a href="https://www.youtube.com/watch?v=LloG_Jn_TI0&amp;t=51s">參考影片</a>)後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="/downloads/fourbar_ball_throwing_linkage.slvs">fourbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><a href="/downloads/sixbar_ball_throwing_linkage.slvs">sixbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><img alt="" height="264" src="/images/fourbar_ball_throwing_linkage.gif" width="400"/></p>
<h2>HW1</h2>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號</p>
<p>執行結果於17:02</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/pmZhnXGU_VI" width="560"></iframe></p>
<h2>HW2</h2>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號</p>
<p>執行結果於15:38</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/dBJZD2FBSps" width="560"></iframe></p>
<p></p>
<h2>HW3</h2>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號</p>
<p></p>
<h1>Midterm</h1>
<p>本課程所繳交的期中成績為學員自評之學習期望成績.</p>
<p>期中考週的自評期望成績繳交流程:</p>
<ol>
<li>整理先前所完成的各週的進度、作業網頁內容以及心得</li>
<li>拍攝期中自評影片, 上傳至 Youtube 後, 以"<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號</span>"為影片標題後嵌入本頁面中</li>
<li>回填期中自評表單</li>
<li>上傳學員期中成績</li>
</ol>
<p>各週進度:</p>
<p>w2-w3:各個github前置作業以及班級list整理學習</p>
<p>w4:solvespace及webot四連桿練習</p>
<p>w5-w6:第二版四連桿繪製組裝與導入webot練習</p>
<p>w7:Blender換色以及<span>basket_ball_shooter繪製組裝</span></p>
<p>各週網頁內容:<a href="https://mdecd2025.github.io/hw-41023114/content/repo.html">repo</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/list.html">list</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/ipv6.html">ipv6</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w3.html">w3</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w4.html">w4</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w6.html">w6</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w7.html">w7</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/Blender.html">Blender</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/HW1.html">HW1</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/HW2.html">HW2</a></p>
<p>期中心得:我認為這堂課我學到很重要的一件事，"自學"，至少我認為在這堂課中到現在為止，自學都是很重要的，而自學所要花的功夫就深了，要找資料、方法、或是問朋友，但總歸都是得花大量時間來完成。</p>
<p>期中自評影片:上面為心得，下面為自評</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JyWpHF4FPPI" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/sZDUqZPH_YE" width="560"></iframe></p>
<h1>Exam</h1>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p style="padding-left: 30px;">各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景 </p>
<p style="padding-left: 30px;">各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p style="padding-left: 30px;">各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站.</p>
<p style="padding-left: 30px;">協同分組方式:</p>
<ol>
<li>分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁.</li>
</ol>
<h2>Exam1</h2>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號</p>
<h2>Exam2</h2>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號</p>
<h2>Exam3</h2>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號</p>
<h1>Final</h1>
<p><span>期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%)</span></p>
<p><span>題目: <span style="background-color: #ccffcc;">Webots 動態投籃模擬系統的協同設計</span></span></p>
<p><span>說明: </span></p>
<p style="padding-left: 30px;"><span>籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上.</span></p>
<p style="padding-left: 30px;"><span>操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止.</span></p>
<p>請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中.</p>
<p>影片標題: <span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題<br/></span></p>
<h1>Brython</h1>
<p><button id="add1to100">1 add to 100</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>
<p>&gt;</p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>