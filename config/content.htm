<h1>About</h1>
<p>課程名稱: 協同產品設計實習 - Collaborative Product Design Practice</p>
<p>學員作業網站:<a class="Link--inTextBlock" href="https://mdecd2025.github.io/hw-41023114/">https://mdecd2025.github.io/hw-41023114/</a></p>
<p>學員作業倉儲:https://github.com/mdecd2025/hw-41023114</p>
<hr/>
<p>課程代號: cd2025</p>
<p>Teams 線上教學:</p>
<p style="padding-left: 30px;">以 "學號@nfu.edu.tw" 登入<span> </span><a href="https://login.microsoftonline.com/">https://login.microsoftonline.com/</a><span> </span>Office 365</p>
<p style="padding-left: 30px;">Teams 團隊代碼: <span>p5z4eku</span></p>
<hr/>
<p>課程評分:</p>
<p style="padding-left: 30px;">Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單</p>
<p style="padding-left: 30px;">Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單</p>
<p style="padding-left: 30px;">Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單</p>
<h2>repo</h2>
<p>tokentest</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/dKuPgrxxRBc" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/on3H-S4DW8g" width="560"></iframe></p>
<h1>Tasks</h1>
<h2>Tasks1</h2>
<p>自行製作、更新可攜程式系統</p>
<p>利用 C:\Portable_2023_fall 啟動舊版的可攜程式環境, 目的是要藉由舊版的 Python 執行 <a href="https://mdecd2025.github.io/hw-scrum-1/downloads/gen_p3132.py">gen_p3132.py</a>, 取得基本的 Python 後, 修改 start.bat, 以 Python313 啟動可攜.</p>
<p>之後利用 Python 3.13.2 在命令列執行<span> </span><a href="https://mdecd2025.github.io/hw-scrum-1/downloads/get-pip.py">get-pip.py</a>, 以便安裝 pip.exe.</p>
<p>之後利用新版的 SciTE, Portablegit, PUTTY, ShareX, Wink 以及原有的 tmp 及 home_ipv6, 以另存新的<span> start.bat</span><span> </span>啟動.</p>
<p>以下為操作影片, 影片中採用兩年前 C: 中的 Python 3.11 舊系統自製、更新為 Python 3.13.2 為主的新可攜程式環境.</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/O00C2PnaPO8" width="560"></iframe></p>
<h3>list</h3>
<p>此為2b list 以下有操作紀錄影片</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023114/ddb7e62d6da50c2e94b70bd6b6c67b66/raw/fc24defff76dd38a0f4ed0bcb411d4c2bf263b48/list4"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/41023114/ddb7e62d6da50c2e94b70bd6b6c67b66/raw/fc24defff76dd38a0f4ed0bcb411d4c2bf263b48/list4"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2PFCBBmQmso" width="560"></iframe></p>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p></p>
<h2>Tasks2</h2>
<h3>ipv6</h3>
<p>以下有操作紀錄影片</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/ipv6+number"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/ipv6+number"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/LUBZG4Enoko" width="560"></iframe></p>
<h3>w3</h3>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/teamX3"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/41023114/7343b96bb714426651d29fb576ceb846/raw/375ba11415ac4dc05697850a8dc1afb4cd577447/teamX3"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/jsjmZk-UBUw" width="560"></iframe></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>這是上課準備所需學習的借GPT輔助來編撰code以及學習如何與GPT溝通才能得到需要的答案。</p>
<h2>Tasks3</h2>
<h2>Tasks4</h2>
<h3>w6</h3>
<p>solvespace新四連桿連接</p>
<p>建造平面四連桿的尺寸設計: 固定桿長度<strong>連結圓心</strong>長為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m</p>
<p><a href="/downloads/4linkslvs.7z">4linkslvs.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ZQ5uWo83qr0" width="560"></iframe></p>
<p>在onshape中繪製圖形導入webots</p>
<p>其中繪製時要將尺寸訂為原本的10倍，如此導入後不會縮小</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JHluhnBsEN4" width="560"></iframe></p>
<p>修正後可運動結果</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/TEx45fWxmt0" width="560"></iframe></p>
<p>此為模擬檔案</p>
<p><a href="/downloads/4linkwe.7z">4linkwe.7z</a></p>
<p>從上上周理解了webot的座標關係後，到了做第二版的四連桿已經比較上手了，中間一周是在了解甚麼東西可以產生webot所需要的obj檔，因此才有上面三部影片。</p>
<h3>w4</h3>
<p><strong>建造平面四連桿的尺寸設計: 固定桿長度為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m</strong></p>
<p>1.建立robot群組</p>
<p>2.robot下的children建立1個solid群組，2個higejoint群組，並選一個為首要，命名為joint1</p>
<p>3.solid的children中建立shape作為固定桿(X1,Y0.1,Z0.1)</p>
<p>4.<span>joint1下的endpoint選擇solid性質，命名為link1，並往下的children中建立pose及higejoint，pose下在建立shape為主動桿(0.4,0.1,0.1)</span><span>，shape命名為link1，再將主動桿所屬的pose的translation設為(0.2,0,0)(此為link1中心點)，而higejoint為主動桿與第二桿連接，並命名為joint2。</span></p>
<p><span>5.joint1的endpoint下有translation(此為連接處的座標點)，設(-0.5,0,0.1)</span></p>
<p><span>6.在joint1下有boundingObject，選擇pose，往下children選擇USE link1，並調整座標至(0.2,0,0)(與link1的pose座標一致)，在設置physics</span></p>
<p>7.以上順序重複製作，主要為base--&gt;joint1--&gt;link1--&gt;<span>joint2--&gt;link2--&gt;</span><span>joint3--&gt;link3--&gt;joint4</span></p>
<p><span>8.joint4在robot群組中的children，與joint1同排列，並將endpoint設為solidreference，並選為use link3</span></p>
<p><span>9.每一階的joint中各有jointparameters、device、emdpoint，其中link1上的device要加入Rotationalmotor，並命名為motor</span></p>
<p><span>10.而每一階的jointparameters，axis設為(0,0,1)(意為繞z軸旋轉)，但anchor要設為桿的長度，這樣才是joint到joint的距離，分別為(-0.5,0,0)、(0.4,0,0)、(0.6,0,0)，此座標是接續的，原點根據base的起點，另外設置的joint4則為(0.5,0,0)</span></p>
<p><strong></strong></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/65a4Fkog1H0" width="560"></iframe></p>
<p>此為修改後的結果</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/E7of8Y-qv24" width="560"></iframe></p>
<p><span>起初操作的過程我認為十分困難，大概花了3天學習webots，光是理解各個座標存在的相應關係、原理，就十分需要下功夫，更何況這並不是借老師範本就能一次成功的作業。</span></p>
<h2>Tasks5</h2>
<h3>Blender</h3>
<p>Blender顏色更改</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/OHl5c13Icg0" width="560"></iframe></p>
<p>這是在上課時老師講解到的換色功能，在課堂中學習使用，下課後自行修改。</p>
<h3>w7</h3>
<p>在老師的<a href="https://mde.tw/cd2025/downloads/cd2025_hw1_demo.7z">cd2025_hw1_demo.7z</a>檔案中有三個split_stl_to_obj_scale的檔案，先將solvespace中四連桿機構從</p>
<p>左上的File-&gt;Export Triangle Mesh下載STL檔，並在<span>split_stl_to_obj_scale的最下面有</span></p>
<p><span><img alt="" height="120" src="/images/螢幕擷取畫面 2025-04-01 184002.png" width="347"/></span></p>
<p><span>將STL檔案輸入於上面，並將這個python檔案帶入你要轉換的資料夾中，然後再使用SciTE執行，他會產生split_parts資料夾，並自動將obj檔都整理再此資料夾中。</span></p>
<p><span>最後再將此obj檔直接導入webot中，將可不用自行訂製座標。</span></p>
<p>操作影片於<a href="https://mdecd2025.github.io/hw-41023114/content/HW2.html">HW2</a></p>
<hr/><!-- ########################################## -->
<p>solvespace basket_ball_shooter繪製</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/FxjXAogp-wk" width="560"></iframe></p>
<p><span>solvespace basket_ball_shooter組裝</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/iOeLvm_IQMg" width="560"></iframe></p>
<p>基本的四連桿都練習過後，接下來做的就是實現四連桿實用，這兩部影片最大的困難是shooter的組裝，上傳的是成功的影片，第一次組裝時應該花了下午到晚上的時間，要理解組裝方向及相對關係才能排出先平行還是先共點。</p>
<h3>w9</h3>
<p>shooter導入webot</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/v_c-pkeymm0" width="560"></iframe></p>
<p>最大速度修改方法:</p>
<p>joint1--&gt;device--&gt;RotationalMotor--&gt;maxVelocity、maxTorque改10000 </p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/8vzJpdpREn4" width="560"></iframe></p>
<h3>w11</h3>
<p><span>solvespace籃框繪製</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/DQk0Yih2fQ8" width="560"></iframe></span></p>
<p><span></span></p>
<p><strong>導入webot中:</strong></p>
<p>1.籃框要加入robot的children下並使用solid</p>
<p><img alt="" height="143" src="/images/螢幕擷取畫面 2025-04-30 133246.png" width="200"/>，，<img alt="" height="166" src="/images/stand2.png" width="200"/>，，</p>
<p>接下來加入籃框跟籃框sensor</p>
<p><img alt="" height="143" src="/images/stand3.png" width="200"/>，，<img alt="" height="201" src="/images/stand4.png" width="200"/>，，<img alt="" height="246" src="/images/stand5.png" width="200"/>，，</p>
<p>接下來更改sensor顏色存在</p>
<p><img alt="" height="196" src="/images/stand6.png" width="200"/>，，<img alt="" height="206" src="/images/stand7.png" width="200"/></p>
<p></p>
<p>2.加入球體</p>
<p><img alt="" height="186" src="/images/ball1.png" width="200"/>，，<img alt="" height="138" src="/images/ball2.png" width="200"/></p>
<p></p>
<p>3.加入地板</p>
<p><img alt="" height="204" src="/images/floor.png" width="200"/></p>
<p></p>
<p>4.更改worldinfo</p>
<p><img alt="" height="201" src="/images/worldinfo1.png" width="200"/>，，<img alt="" height="204" src="/images/worldinfo2.png" width="200"/></p>
<p></p>
<p>目前問題:不確定是籃框的甚麼部分設定出現問題，fourbar可以擊球，但碰到籃板後卻穿透了。</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/SRh9d7TlRqU" width="560"></iframe></p>
<h2>Tasks6</h2>
<h3>Tutorial1</h3>
<p><strong>Start webots</strong></p>
<p>1.啟動 Webots<br/>如果你還沒安裝 Webots，請先下載並安裝。安裝完成後，雙擊 Webots 的圖示啟動程式。第一次啟動時，可能會要求你選擇介面主題，選擇你喜歡的即可。</p>
<p>2.建立新專案<br/>點選「檔案」&gt;「新建」&gt;「新建專案目錄」，然後設定專案名稱為 my_first_simulation，並將世界檔案命名為 my_first_simulation.wbt。確保勾選「加入矩形競技場」選項，這樣就會自動建立一個包含地板和牆壁的簡單環境。</p>
<hr/><!-- ########################################## -->
<p>Create a New World</p>
<p>A World is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, and the definitions of gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called Nodes and are organized hierarchically in a Scene Tree. Therefore, a node may contain sub-nodes. A world is stored in a file having the .wbt extension. The file format is derived from the VRML97 language, and is human readable. The world files must be stored directly in a directory called worlds.</p>
<p>一個<strong data-end="29" data-start="23">世界</strong>（World）是一個檔案，包含像是物體的位置、外觀、它們如何互動、天空的顏色、以及重力、摩擦力、物體質量等定義的資訊。它定義了模擬的初始狀態。不同的物體被稱為<strong data-end="114" data-start="108">節點</strong>（Nodes），並且以<strong data-end="132" data-start="125">場景樹</strong>（Scene Tree）的階層結構組織。因此，一個節點可能包含子節點。世界檔案儲存在具有 <code data-end="183" data-start="177">.wbt</code> 副檔名的檔案中。該檔案格式源自 VRML97 語言，並且是人類可讀的。世界檔案必須直接儲存在名為 <strong data-end="243" data-start="233">worlds</strong> 的資料夾中。</p>
<p>World – 世界，這是 Webots 的基本檔案類型，定義模擬的初始狀態。</p>
<p>File – 檔案，這裡指的是儲存世界資訊的檔案。</p>
<p>Objects – 物體，Webots 中的模擬物件。</p>
<p>Interact with – 互動，指的是物體之間的交互行為。</p>
<p>Color of the sky – 天空顏色，環境的一部分，通常會在背景設定中修改。</p>
<p>Gravity – 重力，物理參數之一。</p>
<p>Friction – 摩擦力，物理參數之一。</p>
<p>Masses – 質量，物理參數之一。</p>
<p>Nodes – 節點，Webots 中的基本物件，可以包含其他物件（子節點）。</p>
<p>Scene Tree – 場景樹，將節點按照層次結構組織的方式。</p>
<p>Sub-nodes – 子節點，節點下層的結構。</p>
<p>.wbt extension – .wbt 副檔名，Webots 世界檔的格式。</p>
<p>VRML97 – 一種三維虛擬現實建模語言，Webots 世界檔格式來源。</p>
<p>Human readable – 人類可讀，表示該檔案格式容易理解。</p>
<p></p>
<p>1.A is B that...</p>
<p>用來解釋 A 是 B 且 B 是什麼，這是一個常見的定義句型。</p>
<p>例句：</p>
<p>"A World is a file containing information like..."<br/>→ 「世界是一個包含以下資訊的檔案……」</p>
<p>2.like</p>
<p>用來舉例或列出類似的事物。</p>
<p>例句：</p>
<p>"...information like where the objects are, what they look like..."<br/>→ 「像是物體的位置、外觀等資訊」</p>
<p>3.and</p>
<p>用來連接詞語或句子中的多個項目。</p>
<p>例句：</p>
<p>"...the color of the sky, and the definitions of gravity, friction..."<br/>→ 「天空顏色，還有重力、摩擦力的定義」</p>
<p>4.Therefore</p>
<p>表示因果關係，通常用來引出結論。</p>
<p>例句：</p>
<p>"Therefore, a node may contain sub-nodes."<br/>→ 「因此，一個節點可能包含子節點。」</p>
<p>5.may</p>
<p>表示可能性，用來描述不確定的情況。</p>
<p>例句：</p>
<p>"A node may contain sub-nodes."<br/>→ 「一個節點可能會包含子節點。」</p>
<p>6.having</p>
<p>用來描述具有某種特徵的事物。</p>
<p>例句：</p>
<p>"A world is stored in a file having the .wbt extension."<br/>→ 「世界檔案是儲存在具有 .wbt 副檔名的檔案中。」</p>
<p>7.derived from</p>
<p>表示某事物來源於或基於某個東西。</p>
<p>例句：</p>
<p>"The file format is derived from the VRML97 language."<br/>→ 「檔案格式來源於 VRML97 語言。」</p>
<p>8.must be</p>
<p>用來強調必須做某事，是義務或要求。</p>
<p>例句：</p>
<p>"The world files must be stored directly in a directory called worlds."<br/>→ 「世界檔案必須直接儲存在名為 worlds 的資料夾中。」</p>
<p>主要是在講解場地</p>
<p>調整地板和牆壁大小<br/>在「場景樹」中選擇 RectangleArena，然後調整以下參數：</p>
<p>floorTileSize：改為 0.25 0.25，讓地板磚塊變小。</p>
<p>wallHeight：改為 0.05，讓牆壁變矮。</p>
<p>加入木箱<br/>點選「新增」按鈕，選擇 PROTO nodes (Webots Projects) / objects / factory / containers / WoodenBox (Solid)，在競技場中間會出現一個大箱子。選擇這個箱子，然後調整以下參數：</p>
<p>size：改為 0.1 0.1 0.1，讓箱子變小。</p>
<p>translation：改為 0 0 0.05，讓箱子稍微浮起。</p>
<p>接著，使用複製貼上（Ctrl+C 和 Ctrl+V）來新增兩個箱子，並將它們移動到競技場的不同位置，避免它們都集中在中間。</p>
<hr/><!-- ########################################## -->
<p><strong>Add an e-puck Robot</strong></p>
<p>The e-puck is a small robot having differential wheels, 10 LEDs, and several sensors including 8 DistanceSensors and a Camera. In this tutorial we are only interested in using its wheels.</p>
<p>e-puck 是一個小型機器人，擁有差速輪、10 顆 LED 燈和幾個感測器，包括 8 顆距離感測器和一個相機。在本教程中，我們只會關注它的輪子。我們會在接下來的教程中學習如何使用其他功能。</p>
<p>主要在講解e-puck機器人</p>
<p>加入 e-puck 機器人<br/>點選「新增」按鈕，選擇 PROTO nodes (Webots Projects) / robots / mobile / e-puck，這樣就會在競技場中加入一台 e-puck 機器人。</p>
<p>設定機器人控制程式<br/>在「場景樹」中選擇 e-puck，然後在 controller 欄位中輸入控制程式的名稱，例如 my_controller。這樣，當我們建立控制程式時，機器人就會使用它來控制行為。</p>
<p></p>
<p>e-puck - 小型機器人，這是 Webots 中的預設機器人之一。</p>
<p>differential wheels - 差速輪，兩個輪子的轉速差控制機器人的移動。</p>
<p>LEDs - 發光二極管，這裡指的是機器人上的燈。</p>
<p>DistanceSensors - 距離感測器，用來測量機器人與物體的距離。</p>
<p>PROTO node - 一種 Webots 節點，用來創建可重用的自定義物件。</p>
<p>Scene Tree - 場景樹，Webots 的節點組織結構。</p>
<p>real-time - 即時模擬模式。</p>
<p>mass - 質量，物體的物理屬性之一。</p>
<p>basicTimeStep - 基本時間步長，用於控制物理模擬的步伐。</p>
<p>reset - 重置，將模擬恢復到初始狀態。</p>
<p>simulation - 模擬，指在 Webots 中執行的虛擬環境。</p>
<p>apply a force - 施加力，用於操控物體的移動。</p>
<p>ctrl key - 控制鍵，用於進行某些操作的快捷鍵。</p>
<hr/><!-- ########################################## -->
<p data-pm-slice="1 1 []"><strong>Create a New Controller</strong></p>
<p>We will now program a simple controller that will just make the robot move forwards. A controller is a program that defines the behavior of a robot. Webots controllers can be written in the following programming languages: C, C++, Java, Python, MATLAB, etc. C, C++ and Java controllers need to be compiled before they can be run as robot controllers. Python and MATLAB controllers are interpreted languages so they will run without being compiled. In this tutorial, we are going to use C as a reference language but all the code snippets are also available in C++, Java, Python and MATLAB. Refer to the language chapter to setup a controller using a different programming language.</p>
<p>The controller field of a Robot node specifies which controller is currently associated to the robot. Note that the same controller can be used by several robots, but a robot can only use one controller at a time. Each controller is executed in a separate child process usually spawned by Webots. Because they are independent processes, controllers don't share the same address space, and may run on different processor cores.</p>
<p class="" data-end="273" data-start="42">控制器是一個程式，用來定義機器人的行為。Webots 控制器可以使用以下程式語言編寫：C、C++、Java、Python、MATLAB 等。C、C++ 和 Java 控制器需要編譯後才能作為機器人控制器運行，而 Python 和 MATLAB 控制器是直譯語言，因此不需要編譯就可以運行。在本教程中，我們將使用 C 作為參考語言，但所有的程式碼片段也會提供 C++、Java、Python 和 MATLAB 版本。若要使用其他程式語言設置控制器，請參閱語言章節。</p>
<p class="" data-end="443" data-start="275">機器人節點（Robot node）的控制器欄位指定了當前與機器人相關聯的控制器。請注意，同一個控制器可以被多個機器人使用，但每次只有一個機器人可以使用同一個控制器。每個控制器都是在一個單獨的子進程中執行，這些子進程通常是由 Webots 啟動的。由於它們是獨立的進程，控制器之間不共享相同的地址空間，並且可能會在不同的處理器核心上運行。</p>
<p>Controller - 控制器：定義機器人行為的程式。</p>
<p>Robot node - 機器人節點：Webots 中的一個節點，代表機器人本身。</p>
<p>Program - 程式：計算機執行的指令集，這裡指的是控制機器人行為的程式。</p>
<p>Compiled - 編譯：將程式碼轉換為機器能執行的格式。</p>
<p>Interpreted - 直譯：程式碼不需要編譯，而是由解釋器直接執行。</p>
<p>Language - 語言：指程式語言，這裡提到 C、C++、Java、Python 和 MATLAB。</p>
<p>Independent processes - 獨立進程：指每個控制器在不同的進程中運行，互不影響。</p>
<p>Address space - 地址空間：記憶體中用來儲存程序和資料的區域。</p>
<p>Processor cores - 處理器核心：處理器中的獨立運算單元。</p>
<p></p>
<p>1.We will now - 用來表示即將進行的動作，語氣較為強調未來行動。</p>
<p>例句：We will now program a simple controller.</p>
<p>2.that will - 用來表示目的或未來的動作。</p>
<p>例句：We will now program a simple controller that will just make the robot move forwards.</p>
<p>3.A controller is a program that - 定義和解釋某事物的結構，這裡是對「控制器」的解釋。</p>
<p>例句：A controller is a program that defines the behavior of a robot.</p>
<p>4.can be written in - 表示某事物可以以某種方式來做，這裡用於說明控制器的語言選擇。</p>
<p>例句：Webots controllers can be written in the following programming languages.</p>
<p>5.may run - 表示可能發生的狀況或行為。</p>
<p>例句：...and may run on different processor cores.</p>
<p>6.is executed in - 描述某事物的運行或執行方式。</p>
<p>例句：Each controller is executed in a separate child process usually spawned by Webots.</p>
<p>7.Refer to - 用來表示參考某資料或章節。</p>
<p>例句：Refer to the language chapter to setup a controller using a different programming language.</p>
<p></p>
<p>主要在講解建立控制程式<br/>在 Webots 中，控制程式是用來定義機器人行為的程式。你可以使用 Python、C、C++、Java 等語言來撰寫控制程式。這裡我們以 Python 為例。</p>
<p>撰寫簡單的前進程式<br/>在 Webots 的控制程式資料夾中，建立一個新的 Python 檔案，命名為 my_controller.py，並輸入以下程式碼：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot, Motor

TIME_STEP = 64
MAX_SPEED = 6.28

robot = Robot()

leftMotor = robot.getMotor('left wheel motor')
rightMotor = robot.getMotor('right wheel motor')

leftMotor.setPosition(float('inf'))
rightMotor.setPosition(float('inf'))

leftMotor.setVelocity(0.1 * MAX_SPEED)
rightMotor.setVelocity(0.1 * MAX_SPEED)

while robot.step(TIME_STEP) != -1:
    pass
</pre>
<p><br/><br/></p>
<hr/><!-- ########################################## -->
<p></p>
<h3>Tutorial2</h3>
<p>在本教學中，我們將學習如何在環境中建立簡單的物件。第一步是建立一顆會與環境互動的球體。我們將探討與節點相關的多個概念：它們的意義、如何建立、如何關聯等。此外，我們還將了解如何設定物理屬性。</p>
<p>將介紹幾種類型的節點。它們的詳細定義可以在參考手冊中找到。擁有節點圖表將有助於理解節點之間的繼承關係。</p>
<hr/><!-- ########################################## -->
<p><strong>The Solid Node</strong></p>
<p>The Solid Node<br/>This subsection introduces the most important base node in Webots: the Solid node, from which many other nodes derive.</p>
<p>A Solid node represents a rigid body, that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies.</p>
<p>The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies.</p>
<p>To define a rigid body, you will have to create a Solid node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following figure depicts a rigid body and its sub-nodes. The graphical representation of the Solid node is defined by the Shape nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p>這一小節介紹了 Webots 中最重要的基礎節點：<strong>Solid 節點</strong>，許多其他節點都是從它衍生出來的。</p>
<p>Solid 節點代表一個剛體，也就是一種在模擬中可以忽略變形的物體。剛體中任意兩點之間的距離在時間中是保持不變的，即使有外力施加在上面也是如此。例如：桌子、機器人的指節、或是輪子，這些都是剛體。而軟體（soft bodies）或具有關節的物體則不屬於剛體，比如繩子、輪胎、海綿，或是關節式的機器人手臂就不是剛體。不過，一個有關節的物體可以拆解成數個剛體來處理。</p>
<p>Webots 的物理引擎專門用來<strong>模擬剛體</strong>。因此，在設計模擬時，一個重要的步驟就是把各個物件拆解成獨立的剛體。</p>
<p>若要定義一個剛體，你需要建立一個 Solid 節點。在這個節點中，你將設定一些子節點來描述這個剛體的特性。下圖展示了一個剛體及其子節點的結構：</p>
<p><strong>圖形外觀</strong>（Graphical representation） 是由放在 children 清單中的 Shape 節點 來定義的。</p>
<p><strong>碰撞邊界</strong>（Collision bounds） 則是由 boundingObject 欄位來設定。</p>
<p>通常圖形外觀與碰撞形狀是一樣的，但不一定非得相同。</p>
<p>最後，physics 欄位會決定這個物件是屬於<strong>動態物件</strong>還是<strong>靜態環境</strong>的一部分。</p>
<p>所有這些子節點都是可選的，但若要使用 physics 欄位，<strong>就必須定義</strong> boundingObject。</p>
<p><img alt="" height="245" src="/images/螢幕擷取畫面 2025-04-16 220900.png" width="300"/></p>
<p>Solid node Solid 節點、剛體節點 Webots 中用來定義剛體的節點<br/>Rigid body 剛體 一種不會變形的物體<br/>Deformation 變形 通常是物體在受力後的形狀改變<br/>External force 外力 來自外部施加在物體上的力量<br/>Soft body 軟體 可以變形的物體<br/>Articulated object 關節式物體 有連接部位、可活動的物體<br/>Physics engine 物理引擎 模擬物理行為的程式模組<br/>Simulation 模擬 在電腦中模擬現實情境<br/>Sub-node 子節點 階層式結構中的下層節點<br/>Graphical representation 圖形表示 在 3D 視圖中可看到的外觀<br/>Collision bounds 碰撞邊界 用於物理計算的碰撞區域<br/>boundingObject 邊界物件欄位 定義碰撞邊界用的欄位<br/>children list 子節點清單 包含 Shape 等節點的集合<br/>Shape node 形狀節點 描述物體圖形的節點<br/>physics field 物理欄位 決定是否加入動力模擬<br/>dynamical/static environment 動態/靜態環境 是否會移動（物理互動）的物體</p>
<p></p>
<p>1.This subsection introduces...</p>
<p>用來開始段落、介紹某主題。</p>
<p>例句：This subsection introduces the most important base node in Webots.</p>
<p>翻譯：這一小節介紹了 Webots 中最重要的基礎節點。</p>
<p>2.A Solid node represents...</p>
<p>主詞 + 動詞 + 補語 → 用來定義或說明某事物的功能。</p>
<p>例句：A Solid node represents a rigid body.</p>
<p>翻譯：Solid 節點代表一個剛體。</p>
<p>3.can be broken into...</p>
<p>被動語態 + break into，表示可被分成...</p>
<p>例句：An articulated entity can be broken into several rigid bodies.</p>
<p>翻譯：關節式物體可以被分成多個剛體。</p>
<p>4.You will have to...</p>
<p>未來式 + have to，表示「你必須」。</p>
<p>例句：You will have to create a Solid node.</p>
<p>翻譯：你將需要建立一個 Solid 節點。</p>
<p>5....defined by...</p>
<p>表示由...定義、構成。</p>
<p>例句：The graphical representation is defined by the Shape nodes...</p>
<p>翻譯：圖形表示是由 Shape 節點定義的。</p>
<p>6....but not necessarily...</p>
<p>表示「但不一定是…」</p>
<p>例句：...are often but not necessarily identical.</p>
<p>翻譯：通常是相同的，但不一定。</p>
<p>7.All these sub-nodes are optional, but...</p>
<p>對比句型，用來表達例外或限制。</p>
<p>例句：All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p>翻譯：這些子節點都是可選的，但若要使用 physics 欄位，就必須定義 boundingObject。</p>
<p></p>
<p>主要在講解</p>
<p>Solid 節點是 Webots 中最重要的基礎節點之一，代表一個剛體物件。它包含以下子節點：</p>
<p>Shape：定義物件的外觀。</p>
<p>boundingObject：定義物件的碰撞邊界。</p>
<p>physics：定義物件的物理屬性。</p>
<p>這些子節點是可選的，但如果要讓物件具有物理屬性，必須定義 boundingObject 和 physics。</p>
<hr/><!-- ########################################## -->
<p><strong>Create a Ball</strong></p>
<p>We will now add a ball to the simulation. That ball will be modeled as a rigid body as shown in this figure. A Sphere node will be used to define the geometry of our ball.</p>
<p>Hands-on #4: In the scene tree view, select the last node and press the Add button. In the dialog, open the Bases nodes section and select the Solid node. In the scene tree view, expand the Solid node and select its children field. Add a Shape node to it by using the Add button. Select the appearance field of the Shape node and use the Add button to add a PBRAppearance node.</p>
<p>1.Add a Sphere node as the geometry field of the newly created Shape node.<br/>2.Expand the PBRAppearance node and change its metalness field to 0 and its roughness field to 1.<br/>3.Add another Sphere node to the boundingObject field of the Solid.<br/>4.Finally add a Physics node to the physics field of the Solid.<br/>5.By modifying the translation field of the Solid node, place the ball in front of the robot (at {0.2, 0, 0.2} for example).<br/>6.Save the simulation.<br/>7.The result is depicted in this figure.</p>
<p>When the simulation is started, the ball hits the floor. You can move the ball by applying a force to it (ctrl + alt + left-click + drag). The contact points between the ball and the floor can be displayed as cyan lines by enabling the View / Optional Rendering / Show Contact Points menu item.</p>
<p class="" data-end="142" data-start="74">我們現在要在模擬中加入一顆球。這顆球將會被建模為一個<strong data-end="106" data-start="100">剛體</strong>，如下圖所示。我們將使用 <code data-end="127" data-start="119">Sphere</code> 節點來定義這顆球的幾何形狀。</p>
<p class="" data-end="388" data-start="144"><strong data-end="154" data-start="144">實作 #4：</strong><br data-end="157" data-start="154"/> 在 <strong data-end="168" data-start="159">場景樹視圖</strong> 中，選取最後一個節點並按下 <strong data-end="189" data-start="183">新增</strong> 按鈕。在跳出的對話框中，展開 <strong data-end="220" data-start="205">Bases nodes</strong> 區段，然後選擇 <strong data-end="238" data-start="229">Solid</strong> 節點。<br data-end="245" data-start="242"/> 在場景樹視圖中展開這個 Solid 節點，並選取它的 <code data-end="282" data-start="272">children</code> 欄位。接著，按下 <strong data-end="298" data-start="292">新增</strong> 按鈕加入一個 <strong data-end="315" data-start="306">Shape</strong> 節點。<br data-end="322" data-start="319"/> 再選取剛加入的 Shape 節點的 <code data-end="352" data-start="340">appearance</code> 欄位，使用新增按鈕加入一個 <strong data-end="384" data-start="367">PBRAppearance</strong> 節點。</p>
<p class="" data-end="618" data-start="390">在 Shape 節點的 <code data-end="412" data-start="402">geometry</code> 欄位加入一個 <strong data-end="430" data-start="420">Sphere</strong> 節點，作為球的幾何外觀。<br data-end="446" data-start="443"/> 展開 PBRAppearance 節點，將 <code data-end="479" data-start="468">metalness</code> 欄位改為 <strong data-end="490" data-start="485">0</strong>，<code data-end="502" data-start="491">roughness</code> 欄位改為 <strong data-end="513" data-start="508">1</strong>。<br data-end="517" data-start="514"/> 在 Solid 節點的 <code data-end="545" data-start="529">boundingObject</code> 欄位中再加入一個 <strong data-end="565" data-start="555">Sphere</strong> 節點，用來定義碰撞邊界。<br data-end="581" data-start="578"/> 最後，在 <code data-end="595" data-start="586">physics</code> 欄位加入一個 <strong data-end="614" data-start="603">Physics</strong> 節點。</p>
<p class="" data-end="697" data-start="620">透過修改 Solid 節點的 <code data-end="648" data-start="635">translation</code> 欄位，把球放在機器人前面的位置（例如設為 <code data-end="685" data-start="670">{0.2, 0, 0.2}</code>）。<br data-end="690" data-start="687"/> 儲存這個模擬。</p>
<p class="" data-end="756" data-start="699">這是你在 Webots 中建立的第一個剛體。</p>
<p class="" data-end="905" data-start="758">當你開始模擬後，球會落到地板上。你可以透過施加力來移動這顆球（按住 <code data-end="811" data-start="792">Ctrl + Alt + 左鍵拖曳</code>）。<br data-end="816" data-start="813"/> 若你想查看球與地面接觸的點，可以從功能表中點選：<strong data-end="891" data-start="840">View &gt; Optional Rendering &gt; Show Contact Points</strong>，就會以青綠色線條顯示出來。</p>
<p class="" data-end="905" data-start="758"></p>
<p class="" data-end="905" data-start="758">Ball 球體 模擬中新增的物件<br/>Rigid body 剛體 不會變形的物體，適合用於物理模擬<br/>Solid node Solid 節點 Webots 中用來定義剛體的節點<br/>Sphere node 球形節點 幾何形狀為球的節點<br/>Shape node 外觀節點 定義圖形外觀<br/>PBRAppearance node 實體外觀節點 用於設定金屬感、粗糙度等外觀屬性<br/>boundingObject 邊界物件欄位 用來定義物理碰撞用的區域<br/>Physics node 物理屬性節點 控制物體是否受重力、摩擦等影響<br/>translation 位移欄位 設定物體在空間中的位置<br/>metalness 金屬感 外觀參數，0 表示非金屬<br/>roughness 粗糙度 外觀參數，1 表示完全粗糙<br/>Apply a force 施加力量 移動物體的方式之一<br/>Contact point 接觸點 物體接觸地面時產生的物理點</p>
<p class="" data-end="905" data-start="758"></p>
<p>1.We will now add...</p>
<p>表示即將執行的操作。</p>
<p>例句：We will now add a ball to the simulation.</p>
<p>翻譯：我們現在要在模擬中加入一顆球。</p>
<p>2.That ball will be modeled as...</p>
<p>被動語態 + as，用於描述物件如何被建模。</p>
<p>例句：That ball will be modeled as a rigid body.</p>
<p>翻譯：這顆球會被建模成一個剛體。</p>
<p>3.Select the ... and press the Add button.</p>
<p>指令句型，常見於操作教學中。</p>
<p>例句：Select the last node and press the Add button.</p>
<p>翻譯：選取最後一個節點並按下新增按鈕。</p>
<p>4.Expand ... and change its ... field to ...</p>
<p>表示進入某節點並修改其欄位。</p>
<p>例句：Expand the PBRAppearance node and change its metalness field to 0.</p>
<p>翻譯：展開 PBRAppearance 節點，將 metalness 欄位設為 0。</p>
<p>5.The result is depicted in this figure.</p>
<p>被動語態，用於說明結果已被圖示。</p>
<p>例句：The result is depicted in this figure.</p>
<p>翻譯：結果如下圖所示。</p>
<p>6.You can move the ball by...</p>
<p>by + V-ing，表示透過某動作達成某目的。</p>
<p>例句：You can move the ball by applying a force to it.</p>
<p>翻譯：你可以透過施加力量來移動這顆球。</p>
<p>7.can be displayed by enabling...</p>
<p>被動語態 + by V-ing，表示可以透過某操作來達成。</p>
<p>例句：The contact points can be displayed by enabling the View menu...</p>
<p>翻譯：接觸點可以透過啟用 View 選單來顯示。</p>
<p></p>
<p>主要在講解如何建立球體</p>
<p><strong>1.新增 Solid 節點</strong><br/>在場景樹中選擇最後一個節點，點擊「新增」按鈕，選擇 Base nodes 中的 Solid 節點。</p>
<p><strong>2.新增 Shape 節點</strong><br/>展開 Solid 節點，選擇 children 欄位，點擊「新增」按鈕，選擇 Shape 節點。</p>
<p><strong>3.設定外觀</strong><br/>展開 Shape 節點，選擇 appearance 欄位，點擊「新增」按鈕，選擇 PBRAppearance 節點。將 metalness 設為 0，roughness 設為 1。</p>
<p><strong>4.設定幾何形狀</strong><br/>在 Shape 節點中，選擇 geometry 欄位，點擊「新增」按鈕，選擇 Sphere 節點。將 radius 設為 0.05，subdivision 設為 2。</p>
<p><strong>5.設定碰撞邊界</strong><br/>在 Solid 節點中，選擇 boundingObject 欄位，點擊「新增」按鈕，選擇 Sphere 節點。將 radius 設為 0.05，subdivision 設為 2。</p>
<p><strong>6.設定物理屬性</strong><br/>在 Solid 節點中，選擇 physics 欄位，點擊「新增」按鈕，選擇 Physics 節點。</p>
<p><strong>7.設定位置</strong><br/>在 Solid 節點中，選擇 translation 欄位，將其值設定為 {0.2, 0, 0.2}，將球體放置在機器人前方。</p>
<p><strong>8.儲存模擬</strong><br/>完成上述步驟後，儲存模擬檔案。</p>
<hr/><!-- ########################################## -->
<p><strong>Geometries</strong></p>
<p>To define the ball, we used the Sphere node in two different contexts: for the graphical representation (children) and to define the physical bounds (boundingObject). All Geometry nodes (such as the Sphere node) can be used in a graphical context. However, only a subset of them can be used in a physical context. The nodes chart diagram indicates which nodes are supported in each context.</p>
<p>We are now going to reduce the size of the Sphere and increase its graphical quality by increasing the number of triangles used to represent it.</p>
<p>Hands-on #5: For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for.</p>
<p>為了定義這顆球，我們在兩種不同的情境中使用了 Sphere（球體）節點：<br/>一是在圖形呈現（children）中，另一個則是用來定義物理邊界（boundingObject）。<br/>所有的幾何節點（像是 Sphere）都可以用在圖形呈現的情境中。<br/>然而，只有其中一部分的幾何節點可以用在物理模擬的情境中。<br/>你可以參考節點圖（nodes chart diagram），來確認每個節點在哪些情境中是被支援的。</p>
<p>接下來我們要縮小球的大小，並且提升圖形品質，方法是增加用來呈現球體的三角形數量。</p>
<p><strong>實作#5</strong></p>
<p>對每一個定義球體的 Sphere 節點，將：</p>
<p>radius 欄位設為 0.05，</p>
<p>subdivision 欄位設為 2。</p>
<p>若想進一步了解 subdivision 欄位的用途，可以參考官方的 Reference Manual（參考手冊）。</p>
<p></p>
<p>Geometry 幾何形狀 通常用來定義 3D 物件的外觀<br/>Sphere node 球體節點 幾何節點之一，用來建立球形物件<br/>Graphical representation 圖形呈現 指物體在 3D 視窗中看到的樣子<br/>BoundingObject 邊界物件 物體的碰撞範圍，為物理模擬用<br/>Physical context 物理情境 用於碰撞、重量、力等模擬計算<br/>Subset 子集合、部分 指從一大類中選出的某幾個<br/>Reduce 減少、降低 常用於尺寸、數量等<br/>Subdivision 分割數、細分數 決定幾何圖形的精細度（三角形數）<br/>Radius 半徑 控制球體的大小<br/>Reference Manual 參考手冊 官方說明文件</p>
<p></p>
<p>1.We used the Sphere node in two different contexts.</p>
<p>表示「我們在兩種不同情境下使用了 Sphere 節點」。</p>
<p>in [情境] context 是很實用的寫法！</p>
<p>例句翻譯：我們在兩種不同的情境中使用了 Sphere 節點。</p>
<p>2.All Geometry nodes can be used in a graphical context.</p>
<p>can be used：被動語態，表示「可以被使用」。</p>
<p>例句翻譯：所有幾何節點都可以用在圖形呈現中。</p>
<p>3.Only a subset of them can be used in a physical context.</p>
<p>only a subset of：只有其中的一部分。</p>
<p>例句翻譯：它們當中只有一部分可以用在物理情境中。</p>
<p>4.We are now going to reduce the size of the Sphere.</p>
<p>be going to + V：表示未來打算做某事。</p>
<p>例句翻譯：我們現在要來縮小球體的大小。</p>
<p>5.Increase its graphical quality by increasing the number of triangles.</p>
<p>by V-ing：藉由做某事來達成目的。</p>
<p>例句翻譯：透過增加三角形數量來提升圖形品質。</p>
<p>6.Set its radius field to 0.05 and its subdivision field to 2.</p>
<p>指令句常用語法，常見於操作說明中。</p>
<p>例句翻譯：將半徑欄位設為 0.05、細分欄位設為 2。</p>
<p></p>
<hr/><!-- ########################################## -->
<p><strong>DEF-USE Mechanism</strong></p>
<p>The DEF-USE mechanism allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node.</p>
<p>The two Sphere definitions that we have used earlier to define the ball, are redundant. We will now merge these two Spheres into only once using the DEF-USE mechanism.</p>
<p>Hands-on #6: Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string.</p>
<p>Enter BALL_GEOMETRY in this field.<br/>Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up.<br/>Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box.<br/>The result is shown in this figure.<br/>Now, changing the radius field of the first Sphere node also modifies its boundingObject.</p>
<p>For convenience, the boundingObject field also accepts the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure. For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors.</p>
<p>DEF-USE 機制可以讓你在場景樹中的某一處定義一個節點，然後在其他地方重複使用這個定義。<br/>這個機制的好處是可以避免在 world 檔中重複建立相同的節點，而且也能同時修改多個使用相同定義的物件。</p>
<p>它的運作方式如下：</p>
<p>1.先使用 DEF 關鍵字替一個節點取一個名稱。</p>
<p>2.接著，在其他位置可以使用 USE 關鍵字來引用這個節點。</p>
<p>3.<strong>只有被 DEF 定義的節點的欄位可以被修改</strong>，USE 的節點會繼承 DEF 的設定，不能獨立編輯。</p>
<p>4.這個機制依賴 world 檔中的節點順序：必須先定義 DEF 節點，才能在後面使用對應的 USE 節點。</p>
<p>我們之前為球體使用了兩個 Sphere 定義，這是重複的。<br/>現在我們要用 DEF-USE 機制，合併成一個 Sphere 節點來重複使用。</p>
<p>實作#6</p>
<ol data-end="739" data-start="507">
<li class="" data-end="548" data-start="507">
<p class="" data-end="548" data-start="510">在場景樹中，選取第一個 <code data-end="530" data-start="522">Sphere</code> 節點（<code data-end="541" data-start="534">Shape</code> 的子節點）。</p>
</li>
<li class="" data-end="593" data-start="549">
<p class="" data-end="593" data-start="552">在欄位編輯器中輸入 <code data-end="567" data-start="562">DEF</code> 名稱 → <strong data-end="592" data-start="573"><code data-end="590" data-start="575">BALL_GEOMETRY</code></strong>。</p>
</li>
<li class="" data-end="669" data-start="594">
<p class="" data-end="642" data-start="597">選取 <code data-end="616" data-start="600">boundingObject</code> 欄位（裡面原本有第二個 <code data-end="637" data-start="629">Sphere</code> 節點）：</p>
<p class="" data-end="669" data-start="648">   右鍵 → 選擇「Delete」來清空內容。</p>
</li>
<li class="" data-end="739" data-start="670">
<p class="" data-end="739" data-start="673">再次選取 <code data-end="694" data-start="678">boundingObject</code> 欄位 → 按 <strong data-end="709" data-start="702">Add</strong> → 選擇 <strong>USE / BALL_GEOMETRY。</strong></p>
</li>
</ol>
<p class="" data-end="838" data-start="741">如圖所示，現在只用一個 Sphere 就能同時定義圖形外觀和碰撞邊界。<br data-end="779" data-start="776"/> <strong data-end="838" data-start="779">當你改變第一個 Sphere 的 <code data-end="806" data-start="798">radius</code> 時，它的 <code data-end="828" data-start="812">boundingObject</code> 也會跟著改變。</strong></p>
<p class="" data-end="949" data-start="840">另外，為了方便起見，<code data-end="866" data-start="850">boundingObject</code> 欄位其實也可以接受整個 <code data-end="886" data-start="879">Shape</code> 節點（不只限於 <code data-end="903" data-start="895">Sphere</code>）。<br data-end="908" data-start="905"/> 因此也可以將整個 <code data-end="924" data-start="917">Shape</code> 節點用 <code data-end="938" data-start="929">DEF-USE</code> 重複使用，如圖所示。</p>
<p class="" data-end="1022" data-start="951">目前這樣做最大的好處是可以直接把這個 <code data-end="977" data-start="970">Shape</code> 用來做圖形呈現，<br data-end="989" data-start="986"/> 以後我們在設定感測器（sensor）時，也會發現這個機制非常實用。</p>
<p class="" data-end="1022" data-start="951"></p>
<p class="" data-end="1022" data-start="951">DEF-USE mechanism 定義與重複使用的機制 Webots 中節點重用的重要工具<br/>Scene tree 場景樹 所有節點階層結構的視覺呈現<br/>Node 節點 Webots 中的基本建構單元<br/>Field editor 欄位編輯器 可編輯節點屬性的地方<br/>BoundingObject 碰撞邊界物件欄位 定義物理碰撞區域<br/>Graphical representation 圖形呈現 物體在 3D 視圖中所呈現的外觀<br/>Context menu 快速選單、右鍵選單 使用者右鍵點擊時出現的功能選單<br/>Convenience 便利性、方便性 在說明某功能使用上較為方便時常見用詞<br/>Inherit 繼承 指 USE 會繼承 DEF 的屬性設定</p>
<p class="" data-end="1022" data-start="951"></p>
<p>1.The DEF-USE mechanism allows [動詞片語]</p>
<p>表示「這個機制可以讓你做…」</p>
<p>The DEF-USE mechanism allows to define a node…</p>
<p>DEF-USE 機制可以讓你定義節點…</p>
<p>2.Only the fields of the DEF node can be edited.</p>
<p>被動語態 + 限定詞 only，常見於規則說明。</p>
<p>Only the fields of the DEF node can be edited.</p>
<p>只有 DEF 節點的欄位可以被修改。</p>
<p>3.The fields of the USE inherit from the DEF node.</p>
<p>簡潔地表達繼承關係，用於物件導向、資料繼承等情境。</p>
<p>The fields of the USE inherit from the DEF node.</p>
<p>USE 的欄位會繼承 DEF 的設定。</p>
<p>4.A DEF node should be defined before any corresponding USE node.</p>
<p>should be + 過去分詞：表示應該要做某事的被動句型。</p>
<p>A DEF node should be defined before any corresponding USE node.</p>
<p>DEF 節點應該要在對應的 USE 節點之前定義好。</p>
<p>5.Now, changing the radius field... also modifies its boundingObject.</p>
<p>Now, + V-ing：現在做某事會產生什麼結果。</p>
<p>Now, changing the radius field also modifies its boundingObject.</p>
<p>現在，改變半徑也會同時改變碰撞邊界。</p>
<p></p>
<p>主要在講解DEF-USE機制</p>
<p class="" data-end="1650" data-start="1623">為了減少節點重複，我們可以使用 DEF-USE 機制。</p>
<ol data-end="1880" data-start="1652">
<li class="" data-end="1760" data-start="1652">
<p class="" data-end="1760" data-start="1655"><strong data-end="1668" data-start="1655">設定 DEF 標籤</strong><br data-end="1671" data-start="1668"/> 在場景樹中，選擇 <code data-end="1690" data-start="1683">Shape</code> 節點，展開它，找到 <code data-end="1711" data-start="1701">geometry</code> 欄位，選擇 <code data-end="1726" data-start="1718">Sphere</code> 節點，將 <code data-end="1737" data-start="1732">DEF</code> 欄位設定為 <code data-end="1759" data-start="1744">BALL_GEOMETRY</code>。</p>
</li>
<li class="" data-end="1880" data-start="1762">
<p class="" data-end="1880" data-start="1765"><strong data-end="1778" data-start="1765">使用 USE 標籤</strong><br data-end="1781" data-start="1778"/> 在場景樹中，選擇 <code data-end="1800" data-start="1793">Solid</code> 節點，展開它，找到 <code data-end="1827" data-start="1811">boundingObject</code> 欄位，右鍵點擊，選擇「刪除」。然後，點擊「新增」按鈕，選擇 <code data-end="1879" data-start="1858">USE / BALL_GEOMETRY</code>。</p>
</li>
</ol>
<p class="" data-end="1948" data-start="1882">這樣，當你修改 <code data-end="1905" data-start="1890">BALL_GEOMETRY</code> 的屬性時，所有使用 <code data-end="1937" data-start="1916">USE / BALL_GEOMETRY</code> 的節點都會同步更新。</p>
<hr/><!-- ########################################## -->
<p></p>
<h3>Tutorial3</h3>
<p>The aim of this tutorial is to familiarize yourself with some nodes related to the graphical rendering. Good looking simulations can be created very quickly when these nodes are used adequately. A good graphics quality does not only enhance the user's experience, it is also essential for simulations where robots perceive their environment (camera image processing, line following, etc.).</p>
<p>這個教學的目的是讓你熟悉一些跟圖形渲染相關的節點。只要善用這些節點，就能很快做出視覺效果不錯的模擬畫面。畫面品質好不只會讓使用者體驗更好，對於那些需要靠影像來感知環境的模擬（像是攝影機影像處理、循線等等）來說，也非常重要。</p>
<hr/><!-- ########################################## -->
<p><strong>Light</strong></p>
<p>Lights The lighting of a world is determined by Light nodes and the Background . There are three types of light nodes: the DirectionalLight, the PointLight and the SpotLight. A DirectionalLight simulates a light which is infinitely far (ex: the sun), a PointLight simulates light emitted from a single point (ex: a light bulb), and a SpotLight simulates a conical light (ex: a flashlight). This figure shows a comparison between them. Each type of light node can cast shadows.</p>
<p>一個場景的光線是由 Light 節點和背景來決定的。Light 節點有三種類型：DirectionalLight（方向光）、PointLight（點光源）和 SpotLight（聚光燈）。</p>
<p>DirectionalLight 模擬的是從無限遠處照射過來的光（例如：太陽）。</p>
<p>PointLight 則是從某個點發出來的光（例如：電燈泡）。</p>
<p>SpotLight 則是錐形照射的光（例如：手電筒）。</p>
<p> </p>
<p>lighting 照明、光線配置，指整個場景的光影效果。<br/>determined by 由...決定，常用於說明某件事的因素或來源。<br/>Light nodes 燈光節點，是 Webots 中用來產生光源的物件。<br/>Background 背景，這裡指模擬環境的背景會影響整體照明效果。<br/>DirectionalLight 方向光，模擬來自遠處（如太陽）的平行光。<br/>PointLight 點光源，模擬從一個點向四周發射的光（如燈泡）。<br/>SpotLight 聚光燈，模擬錐形範圍內的光（如手電筒）。<br/>simulate 模擬、模仿，是模擬軟體常見的術語。<br/>cast shadows 投影，意指該光源會產生陰影效果。<br/>Reference Manual 參考手冊，通常指官方文件或說明書。</p>
<p></p>
<p>1.The lighting of a world is determined by Light nodes and the Background.</p>
<p>句型結構：被動語態（is determined by）</p>
<p>主詞：The lighting of a world（這個世界的照明）</p>
<p>動詞：is determined（被決定）</p>
<p>介詞片語：by Light nodes and the Background（由光源節點和背景決定）</p>
<p>用來強調「誰」或「什麼」決定了照明效果，是科技文常見句型。</p>
<p>2.There are three types of light nodes: the DirectionalLight, the PointLight and the SpotLight.</p>
<p>句型結構：There are + 名詞（用來說明有某些東西存在）</p>
<p>適合用來介紹種類、列表或分類。</p>
<p>3.A DirectionalLight simulates a light which is infinitely far.</p>
<p>文法重點：</p>
<p>which is infinitely far 是形容詞子句，用來修飾「light」</p>
<p>infinitely 為副詞，修飾形容詞 far，表示「非常遠」。</p>
<p>常見的定義型句式，用來描述某個東西的作用或特性。</p>
<p>4.Each type of light node can cast shadows.</p>
<p>句型結構：助動詞 can + 原形動詞（cast）→ 表示能力</p>
<p>用來說明這些光源節點有什麼功能。</p>
<p>5.You can find their complete documentation in the Reference Manual.</p>
<p>句型結構：can + find（表達能力/可能）</p>
<p>是一種常見的指引說法，鼓勵讀者去查閱手冊。</p>
<hr/><!-- ########################################## -->
<p><strong>Modify the Appearance of the Walls</strong></p>
<p>Modify the Appearance of the Walls<br/>The aim of this subsection is to color the walls in blue.</p>
<p>The Appearance and PBRAppearance nodes of the Shape node determine the graphical appearance of the object. Among other things, these nodes are responsible for the color and texture of objects.</p>
<p>Prefer PBRAppearances for a better rendering as shown in the following comparison.</p>
<p>Hands-on #2: In the Shape node representing graphically the first wall, add a PBRAppearance node to the appearance field.</p>
<p>Set its baseColor field to blue using the color selector.<br/>Set its metalness field to 0 using the field editor.<br/>Finally, set its roughness field to 0.5 using the field editor.<br/>If the DEF-USE mechanism of the previous tutorial has been correctly implemented, all the walls should turn blue.</p>
<p>Add an Existing Appearance to the Ball<br/>A number of pre-defined PBRAppearance are provided in the Webots release.</p>
<p>Hands-on #3: Add a pre-defined PBRAppearance</p>
<p>Select the appearance field and remove the previously added node. To do this, either press the "delete" button on your keyboard or right-click on the field and select "delete" from the menu. The field should now say "appearance NULL" instead of "appearance PBRAppearance".<br/>Double-click on the field again, then navigate to PROTO nodes (Webots Projects), then appearances and select OldSteel (PBRAppearance).</p>
<p></p>
<p>修改牆壁的外觀<br/>這一小節的目標是把牆壁改成藍色的。</p>
<p>在 Webots 中，Shape 節點裡的 Appearance 跟 PBRAppearance 這兩個節點會決定物件的外觀。像是顏色、材質（紋理）等等都是靠它們設定的。</p>
<p>為了讓畫面更真實，建議你使用 PBRAppearance，下面這張圖就展示了兩者的差別。</p>
<p></p>
<p>實做 #2：讓第一面牆變藍色<br/>找到用來顯示第一面牆的 Shape 節點，在它的 appearance 欄位加上一個 PBRAppearance 節點。</p>
<p>把 baseColor（底色）設成藍色，可以用顏色選擇器來設。</p>
<p>把 metalness（金屬感）設成 0，用欄位編輯器改。</p>
<p>把 roughness（粗糙度）設成 0.5，也是一樣用欄位編輯器改。</p>
<p>如果你有按照前一個教學設定好 DEF-USE 機制，那麼只要改一面牆，其他牆也會一起變藍。</p>
<p>##給球體加上已經做好的外觀<br/>Webots 裡面其實有一堆預設好的 PBRAppearance，可以直接拿來用。</p>
<p>實做 #3：套用一個預設的 PBRAppearance<br/>先選到球體的 appearance 欄位，刪掉原本加的節點。可以按鍵盤上的 delete，或者右鍵點選「delete」。</p>
<p>成功刪除的話，欄位會從「appearance PBRAppearance」變成「appearance NULL」。</p>
<p>接著再雙擊這個欄位，然後依序點進：</p>
<p>PROTO nodes (Webots Projects) → appearances → 選 OldSteel (PBRAppearance)。</p>
<p></p>
<p><br/>Appearance / PBRAppearance 控制物件的外觀樣式，PBRAppearance 提供更真實的渲染效果。<br/>Shape node Webots 中用來表示物體形狀的節點。<br/>baseColor 物件的底色。<br/>metalness 金屬感，用數值表達材質像不像金屬（0 = 非金屬，1 = 金屬）。<br/>roughness 粗糙程度，數值越高越不光滑。<br/>field editor 欄位編輯器，用來改節點的屬性。<br/>color selector 顏色選擇器，點選後可選顏色。<br/>appearance NULL 表示目前沒有設定 appearance。<br/>PROTO node 預先定義好的節點，可以重複使用。<br/>DEF-USE 機制 Webots 中讓一個節點可以重複使用的機制。</p>
<p></p>
<p>1.The aim of this subsection is to...</p>
<p>結構：主詞 + be 動詞 + to V</p>
<p>用來說明某段教學的目的，很常見於技術文件。</p>
<p>2.Among other things, these nodes are responsible for...</p>
<p>表達「除了其他功能外，這些節點的責任是...」</p>
<p>be responsible for 表示「負責…」、「控制…」</p>
<p>3.Set its baseColor field to blue using the color selector.</p>
<p>這是一種常見的指令句，用動詞原形開頭（Set），常見於說明手冊。</p>
<p>using + 工具 → 表示用什麼工具去完成動作。</p>
<p>4.If the DEF-USE mechanism... has been correctly implemented...</p>
<p>現在完成式被動語態：has been + 過去分詞</p>
<p>表示某個設定是否已經正確完成。</p>
<p>5.Select the appearance field and remove...</p>
<p>這類句子都是指令式，直接用動詞原形（Select, Remove）開頭，常見於步驟教學。</p>
<hr/><!-- ########################################## -->
<p data-pm-slice="0 0 []"><strong>Add a Texture from Disk</strong></p>
<p>Add a Texture from Disk The aim of this subsection is to apply a locally available texture to the ball. A texture on a rolling object can help to appreciate its movement. Hands-on #4: add a locally available texture to the ball. Download the texture available here and save it to your disk. Remove the previously added node from the appearance field and add a PBRAppearance node instead. Add an ImageTexture node to the baseColorMap field of the PBRAppearance node. Add an item to the ImageTexture's url field using the Add button. Then set the value of the newly added url item using the "Select" button. Follow the path to the location where you saved the texture and select it. The texture URLs must be defined either relative to the worlds directory of your project directory or relative to the default project directory WEBOTS_HOME/projects/default/worlds. Open the red_brick_wall.jpg texture in an image viewer while you observe how it is mapped onto the Sphere node in Webots. Textures are mapped onto Geometry nodes according to predefined UV mapping functions described in the Reference Manual. A UV mapping function maps a 2D image representation to a 3D model.</p>
<p></p>
<p>這一小節的目的是把本機電腦上的材質圖貼到球體上。<br/>球體有材質圖的話，當它在滾動時，你會更容易看出它的動作。</p>
<p>實作 #4：給球體加上一張本地的材質貼圖<br/>先下載這裡提供的材質圖，然後把它存到你的電腦上。</p>
<p>到 appearance 欄位，把之前加的節點刪掉，改成加一個 PBRAppearance 節點。</p>
<p>在這個 PBRAppearance 裡的 baseColorMap 欄位，加一個 ImageTexture 節點。</p>
<p>點一下 ImageTexture 的 url 欄位，用「Add」按鈕新增一個項目。</p>
<p>新增完以後，按「Select」按鈕，選取你剛才下載的圖片。</p>
<p>找到你存放圖片的資料夾，選取那張圖片。</p>
<p>小提醒：這個圖片的網址（URL）一定要是相對於你的 world 資料夾，或者是相對於 Webots 的預設資料夾：WEBOTS_HOME/projects/default/worlds。</p>
<p>接著，你可以在圖像檢視器中打開這張 red_brick_wall.jpg 圖片，一邊觀察它是怎麼被貼到球體（Sphere node）上的。</p>
<p>貼圖是怎麼運作的？<br/>Webots 會根據預先定義好的 UV mapping 函數，把 2D 的圖片貼到 3D 物件上。</p>
<p>UV mapping 就是把一張平面圖片「攤平」貼到 3D 模型表面的技術，詳細的說明可以看參考手冊。</p>
<p></p>
<p><br/>texture 材質圖、貼圖，用來給物件表面加上圖案或細節。<br/>locally available 本機可用的，表示檔案已經存在於你的電腦中。<br/>apply 套用（某個設定、圖案等）。<br/>rolling object 滾動中的物體（如球）。<br/>ImageTexture Webots 中用來載入圖片貼圖的節點。<br/>url field 圖片的位置（網址或路徑），可以是相對路徑。<br/>baseColorMap 貼圖的位置，會貼在物件的底色上。<br/>relative to 相對於…（用於說明檔案路徑的定位）。<br/>UV mapping 把 2D 圖片對應到 3D 模型的技術。<br/>WEBOTS_HOME Webots 的安裝根目錄（系統預設資料夾）。</p>
<p></p>
<p>1.The aim of this subsection is to...</p>
<p>句型結構：主詞 + be + to V</p>
<p>用來說明這段內容的目標或任務。</p>
<p>2.can help to appreciate its movement</p>
<p>help to V 是常見結構，表示「幫助你能...」</p>
<p>appreciate 在這裡不是「感激」，而是「看得出來、欣賞」。</p>
<p>3.Follow the path to...</p>
<p>這是常見的操作指令句，叫使用者去找某個路徑或資料夾。</p>
<p>4.Textures are mapped onto...</p>
<p>被動語態：Textures are mapped（貼圖被套用到…上）</p>
<p>技術說明中常見的語態，用來解釋系統自動處理的事情。</p>
<p>5.described in the Reference Manual</p>
<p>過去分詞當形容詞使用，說明「被描述於參考手冊中」。</p>
<hr/><!-- ########################################## -->
<p><strong>Rendering Options</strong></p>
<p>Rendering Options Webots offers several rendering modes available in the View menu. Hands-on #5: View the simulation in wireframe mode by using the View / Wireframe Rendering menu item. Then restore the plain rendering mode: View / Plain Rendering. Others rendering features can be helpful: View Coordinates systems: View / Optional Rendering / Show Coordinates System ctrl-F1 View distance sensor rays: View / Optional Rendering / Show DistanceSensor Rays ctrl-F10</p>
<p></p>
<p>Webots 提供了幾種不同的渲染模式，你可以從 View（檢視）選單中切換。</p>
<p>實作 #5：切換線框模式<br/>到選單中點選：View / Wireframe Rendering，就可以切換成 線框模式（看起來像只有線條輪廓的畫面）。</p>
<p>想要恢復正常顯示，選擇：View / Plain Rendering。</p>
<p>除了這些，還有其他實用的渲染功能可以幫助你觀察模擬：</p>
<p>顯示座標系統：View / Optional Rendering / Show Coordinates System（快捷鍵：Ctrl + F1）</p>
<p>顯示距離感測器的光線：View / Optional Rendering / Show DistanceSensor Rays（快捷鍵：Ctrl + F10）</p>
<p></p>
<p>1.Webots offers several rendering modes...</p>
<p>offer + 受詞：提供...</p>
<p>用來介紹功能是很常見的句型。</p>
<p>2.Hands-on #5: View the simulation in wireframe mode...</p>
<p>指令句：直接用動詞原形（View）開頭，常見於教學手冊。</p>
<p>in wireframe mode：用介系詞 in 表示「以某種模式」。</p>
<p>3.Then restore the plain rendering mode...</p>
<p>restore：恢復，這裡用來指切換回預設顯示方式。</p>
<p>4.Others rendering features can be helpful:</p>
<p>正確寫法應該是 Other rendering features（語法上這是小錯誤，other 沒有 s）</p>
<p>can be helpful：可以很有幫助，常見於說明提示中。</p>
<p>5.Show Coordinates System ctrl-F1</p>
<p>命令 + 快捷鍵：這種格式在教學說明中很常見，用來告知操作與快捷鍵對應方式。</p>
<p></p>
<h1>Homework</h1>
<p>作業 (30%)</p>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">part1:</p>
<p style="padding-left: 60px;">請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置:</p>
<p style="padding-left: 90px;">下載 <a href="http://229.cycu.org/portable_wcm2025.7z">portable_wcm2025.7z</a> (330MB, 解開壓縮後 1.4GB)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a.7z">Webots_2025a.7z</a> (1.5 GB, 解開後約為 2.9GB, 可單獨運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a_web.7z">Webots_2025a_web.7z</a> (171 MB, 解開壓縮後約為 1GB, 必須連網運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Blender4.2.7z">Blender4.2.7z</a></p>
<p style="padding-left: 30px;">part2:</p>
<p style="padding-left: 60px;">請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 60px;">base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec.</p>
<p style="padding-left: 30px;">part3:</p>
<p style="padding-left: 60px;">模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/cd2025_hw1_demo.7z">cd2025_hw1_demo.7z</a></p>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/fourbar_slvs.7z">fourbar_slvs.7z</a></p>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p style="padding-left: 30px;">請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 (<a href="https://www.youtube.com/watch?v=LloG_Jn_TI0&amp;t=51s">參考影片</a>)後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="/downloads/fourbar_ball_throwing_linkage.slvs">fourbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><a href="/downloads/sixbar_ball_throwing_linkage.slvs">sixbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><img alt="" height="264" src="/images/fourbar_ball_throwing_linkage.gif" width="400"/></p>
<h2>HW1</h2>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號</p>
<p>執行結果於17:02</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/pmZhnXGU_VI" width="560"></iframe></p>
<p>過程與心得</p>
<p><strong>建造平面四連桿的尺寸設計: 固定桿長度為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m</strong></p>
<p>1.建立robot群組</p>
<p>2.robot下的children建立1個solid群組，2個higejoint群組，並選一個為首要，命名為joint1</p>
<p>3.solid的children中建立shape作為固定桿(X1,Y0.1,Z0.1)</p>
<p>4.<span>joint1下的endpoint選擇solid性質，命名為link1，並往下的children中建立pose及higejoint，pose下在建立shape為主動桿(0.4,0.1,0.1)</span><span>，shape命名為link1，再將主動桿所屬的pose的translation設為(0.2,0,0)(此為link1中心點)，而higejoint為主動桿與第二桿連接，並命名為joint2。</span></p>
<p><span>5.joint1的endpoint下有translation(此為連接處的座標點)，設(-0.5,0,0.1)</span></p>
<p><span>6.在joint1下有boundingObject，選擇pose，往下children選擇USE link1，並調整座標至(0.2,0,0)(與link1的pose座標一致)，在設置physics</span></p>
<p>7.以上順序重複製作，主要為base--&gt;joint1--&gt;link1--&gt;<span>joint2--&gt;link2--&gt;</span><span>joint3--&gt;link3--&gt;joint4</span></p>
<p><span>8.joint4在robot群組中的children，與joint1同排列，並將endpoint設為solidreference，並選為use link3</span></p>
<p><span>9.每一階的joint中各有jointparameters、device、emdpoint，其中link1上的device要加入Rotationalmotor，並命名為motor</span></p>
<p><span>10.而每一階的jointparameters，axis設為(0,0,1)(意為繞z軸旋轉)，但anchor要設為桿的長度，這樣才是joint到joint的距離，分別為(-0.5,0,0)、(0.4,0,0)、(0.6,0,0)，此座標是接續的，原點根據base的起點，另外設置的joint4則為(0.5,0,0)</span></p>
<p><span></span></p>
<p><span>起初操作的過程我認為十分困難，大概花了3天學習webots，這部成功的影片已經是操作過第四次了</span></p>
<p><span><a href="/downloads/HW1.7z">/downloads/HW1.7z</a></span></p>
<h2>HW2</h2>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號</p>
<p>執行結果於15:38</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/dBJZD2FBSps" width="560"></iframe></p>
<p>過程與心得</p>
<p>1.使用HW1的尺寸進行solvespace繪製兩個圓形基座，40的主動桿，60的浮桿，90的搖桿，R4的圓弧，R2.5的孔</p>
<p><span>2.接著使用一開始繪製的線架構草圖進行組裝</span></p>
<p><span>3.組裝完成後存檔，並輸出存檔一個stl檔(Export Triangle Mesh) </span></p>
<p><span>4.將stl使用曾經使用的"split_stl_to_obj_scale2"進行轉obj檔，在4link.stl這個地方做更改，改為自己取的名字.stl</span></p>
<p><span><img alt="" height="120" src="/images/螢幕擷取畫面 2025-04-01 184002.png" width="347"/></span></p>
<p>5.進入webot後，先加入Robot群組</p>
<p>6.在Robot群組下的children加入兩個Solid作為base，再加入兩個Hingejoint一個做為joint1一個為joint4</p>
<p>7.Solid base下的<span>children加入cadshape，並加入剛剛轉好的base的obj檔</span></p>
<p>8.joint1下的endpoint選擇Solid，並加入joint2和cadshape，並將下面的name改link1，在到cadshape下導入剛轉好的obj檔</p>
<p>9.往回點開剛剛加入的joint2，並如joint下的操作，endpoint選擇Solid，並加入joint3、cadshape，並將下面的name改link2</p>
<p><span>10.再找回joint3，並加入最後的link3，</span></p>
<p><span><span>11.最後在回到最頂端找回joint4，並將joint4的endpoint設為Solidrefeference，並選擇剛剛的link3</span></span></p>
<p><span><span>12.回頭補上在endpoint下所有的boundobject，設為Mesh，並選擇對應的obj檔</span></span></p>
<p><span><span>13.再加入physics</span></span></p>
<p><span><span>14.再找回每一階的joint下的jointparameters，每一階的axis旋轉方向都是z軸，因此設為0、0、1，並更改每一階的anchor，joint1的為0、0、0，joint2的為0、0.4、0，joint3的為0.4963、0.7608、0，joint4的為0.5、0、0(這些數據可使用solvespace獲得)(solvespace上的尺寸進入webot需要縮小100倍)。</span></span></p>
<p><span><span>15.加入controller，並在joint1下的device加入Rotationalmotor並改名為motor</span></span></p>
<p><span><span></span></span></p>
<p><span><span>有了先前HW1的基礎後，我認為執行HW2確實輕鬆得多，不過在影片中anchor本還不熟悉，執行完HW2後還有多做過其他檔案的對比，才了解anchor能夠由solvespace取得</span></span></p>
<p><span><span><a href="/downloads/HW2.7z">/downloads/HW2.7z</a></span></span></p>
<h2>HW3</h2>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bqjuXKZ0GhE" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/EmkhbQHjvR4" width="560"></iframe></p>
<p>過程與心得</p>
<p>在先前建立好的fourbar下在加入w11繪製的地板及籃框，籃框要導入Robot群組下並建立sensor，但是我的結果卻出現球碰不籃框籃板的問題，不論在webot2025下還是2023都會出現這樣的問題，不管是將stand移出robot群組使其單獨或是重新加入自有的stand或借demo都會發生，另外也有藉AI幫助進行對比，但並無差異。</p>
<p>最後是由更改籃球框座標後竟然就解決了，將籃框上移，使球碰到籃框支架後再放置回原本的位置，整體的boundobject就計算了，不明白屬於是BUG或是其他條件。</p>
<p><a href="/downloads/HW3.7z">/downloads/HW3.7z</a></p>
<h1>Midterm</h1>
<p>本課程所繳交的期中成績為學員自評之學習期望成績.</p>
<p>期中考週的自評期望成績繳交流程:</p>
<ol>
<li>整理先前所完成的各週的進度、作業網頁內容以及心得</li>
<li>拍攝期中自評影片, 上傳至 Youtube 後, 以"<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號</span>"為影片標題後嵌入本頁面中</li>
<li>回填期中自評表單</li>
<li>上傳學員期中成績</li>
</ol>
<p>各週進度:</p>
<p>w2-w3:各個github前置作業以及班級list整理學習</p>
<p>w4:solvespace及webot四連桿練習</p>
<p>w5-w6:第二版四連桿繪製組裝與導入webot練習</p>
<p>w7:Blender換色以及<span>basket_ball_shooter繪製組裝</span></p>
<p>各週網頁內容:<a href="https://mdecd2025.github.io/hw-41023114/content/repo.html">repo</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/list.html">list</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/ipv6.html">ipv6</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w3.html">w3</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w4.html">w4</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w6.html">w6</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/w7.html">w7</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/Blender.html">Blender</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/HW1.html">HW1</a>、<a href="https://mdecd2025.github.io/hw-41023114/content/HW2.html">HW2</a></p>
<p>期中心得:我認為這堂課我學到很重要的一件事，"自學"，至少我認為在這堂課中到現在為止，自學都是很重要的，而自學所要花的功夫就深了，要找資料、方法、或是問朋友，但總歸都是得花大量時間來完成。</p>
<p>期中自評影片:上面為心得，下面為自評</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JyWpHF4FPPI" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/sZDUqZPH_YE" width="560"></iframe></p>
<h1>Exam</h1>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p style="padding-left: 30px;">各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景 </p>
<p style="padding-left: 30px;">各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p style="padding-left: 30px;">各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站.</p>
<p style="padding-left: 30px;">協同分組方式:</p>
<ol>
<li>分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁.</li>
</ol>
<h2>Exam1</h2>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號</p>
<p>1.先加入Robot群組</p>
<p>2.在Robot群組下的children加入Solid作為base，再加入兩個Hingejoint一個做為joint1一個為joint4</p>
<p>3.joint1下的endpoint選擇Solid，並加入joint2和Pose，並將下面的name改link1</p>
<p>4.endpoint下的translation設-0.5、0、0.1，此為轉軸的座標</p>
<p>5.rotation設為0、0、1、0.244rad(此為學號後兩碼14--&gt;14度轉rad)</p>
<p>6.Pose下的children加入box作為連桿1，長度為0.4、0、0</p>
<p>7.再將Pose的<span>translation設為連桿1長度的一半0.2、0、0</span></p>
<p><span>8.往回點開剛剛加入的joint2，並如joint下的操作，endpoint選擇Solid，並加入joint3、Pose1、Pose2，並將下面的name改link2</span></p>
<p><span>9.joint2下的endpoint下的translation設0.4、0、0.1，此為轉軸2的座標</span></p>
<p><span>10.rotation設為0、0、1、1.25891rad</span></p>
<p><span>11.Pose1下建立長度為0.6、0、0的box，並將Pose1的translation設為連桿2長度的一半0.3、0、0</span></p>
<p><span>12.Pose2下建立長度為0.3、0、0的box，並將Pose2的<span>translation設為0.3、0.15、0，rotation設為</span></span><span><span>0、0、1、-1.57rad</span></span></p>
<p><span>13.再找回joint3，並加入最後的link3，長度為0.9、0、0，endpoint中的translation設0.6、0、-0.1</span></p>
<p><span>14.rotation設為0、0、-1、2.38621<span>rad</span></span></p>
<p><span><span>15.最後在回到最頂端找回joint4，並將joint4的endpoint設為Solidrefeference，並選擇剛剛的link3</span></span></p>
<p><span><span>16.回頭補上在endpoint下所有的boundobject，設為Pose，並在下方的children加上box，Pose座標為以上所有方塊所屬的Pose的座標</span></span></p>
<p><span><span>17.再加入physics</span></span></p>
<p><span><span>18.再找回每一階的joint下的jointparameters，每一階的axis旋轉方向都是z軸，因此設為0、0、1，並更改每一階的anchor，joint1的為-0.5、0、0，joint2的為0.4、0、0，joint3的為0.6、0、0。</span></span></p>
<p><span><span>19.加入controller</span></span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Kv9B5g9pJ64" width="560"></iframe></p>
<p>心得:在執行EXAM1時，我認為核心已經在HW1解決了，剩下就是老師出的考試重點，盡管在影片上花了一點時間整理，但成功後有種開竅的感覺</p>
<p><a href="/downloads/EXAM1.7z">/downloads/EXAM1.7z</a> 此檔案已將顏色變更修正</p>
<h2>Exam2</h2>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號</p>
<p>1.<span>依照個人學號的最後兩碼作為依據，因此我的連桿主動桿訂為1.14而在solve上要變成114，浮桿為160，搖桿為180，基座距離為140。</span></p>
<p><span>2.接著使用一開始繪製的線架構草圖進行組裝(主動桿依據題目限制，訂好角度之後要把角度刪掉令線架構可活動)</span></p>
<p><span>3.組裝完成後存檔，並輸出存檔一個stl檔(Export Triangle Mesh) </span></p>
<p><span>4.將stl使用曾經使用的"split_stl_to_obj_scale2"進行轉obj檔，在4link.stl這個地方做更改，改為自己取的名字.stl</span></p>
<p><span><img alt="" height="120" src="/images/螢幕擷取畫面 2025-04-01 184002.png" width="347"/></span></p>
<p>5.進入webot後，先加入Robot群組</p>
<p>6.在Robot群組下的children加入兩個Solid作為base，再加入兩個Hingejoint一個做為joint1一個為joint4</p>
<p>7.Solid base下的<span>children加入cadshape，並加入剛剛轉好的base的obj檔</span></p>
<p>8.joint1下的endpoint選擇Solid，並加入joint2和cadshape，並將下面的name改link1，在到cadshape下導入剛轉好的obj檔</p>
<p>9.往回點開剛剛加入的joint2，並如joint下的操作，endpoint選擇Solid，並加入joint3、cadshape，並將下面的name改link2</p>
<p><span>10.再找回joint3，並加入最後的link3，</span></p>
<p><span><span>11.最後在回到最頂端找回joint4，並將joint4的endpoint設為Solidrefeference，並選擇剛剛的link3</span></span></p>
<p><span><span>12.回頭補上在endpoint下所有的boundobject，設為Mesh，並選擇對應的obj檔</span></span></p>
<p><span><span>13.再加入physics</span></span></p>
<p><span><span>14.再找回每一階的joint下的jointparameters，每一階的axis旋轉方向都是z軸，因此設為0、0、1，並更改每一階的anchor，joint1的為0、0、0，joint2的為1.1061、0.2934、0，joint3的為1.6408、1.7845、0，joint4的為1.4、0、0(這些數據可使用solvespace獲得)(solvespace上的尺寸進入webot需要縮小100倍)。</span></span></p>
<p><span><span>15.加入controller，並在joint1下的device加入Rotationalmotor並改名為motor</span></span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/nxe0ts2lpj0" width="560"></iframe></p>
<p>心得:在製作時我認為較複雜的部分只有設計整個四連桿長度，其餘部分我認為HW2的轉檔有親自操作過後已經能將EXAM2的95%給完成了</p>
<p><a href="/downloads/EXAM2.7z">/downloads/EXAM2.7z</a> 此為修正過的連桿，浮桿是三角形的</p>
<h2>Exam3</h2>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號</p>
<p>1.先將校園ipv6改為老師事先規範過的個人ipv6，再將自己倉儲中的init.py檔中的ip改為老師規範的ipv6</p>
<p>2.開啟webot --stream建立網頁串聯阜號，並開啟個人HW1的模擬</p>
<p>3.使用http://localhost:1234/index.html</p>
<p>4.將下方網址輸入的localhost改為老師規範的ipv6，如影片上所示，即可作動</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/zoZrZbL7LXM" width="560"></iframe></p>
<p></p>
<!-- editor1 結束 --><hr/>
<p><!-- ########################################## --></p>
<p>1.如EXAM3-1的1 2 3 4步驟相同，僅需將webot中模擬場景改為老師的three_digit_counter.7z</p>
<p>2.使用內建的controller並將seven_segment下的number改為自己學號</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">timestep = int(supervisor.getBasicTimeStep())
    while supervisor.step(timestep) != -1:
        try:
            # Get user input for the number to display
            number = 114
            controller.display_number(number)
        except ValueError:
            print("Invalid input. Please enter an integer between 0 and 999.")</pre>
<p>3.在網頁上重製場景即可</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/y6y-M4HgcAo" width="560"></iframe></p>
<p><a href="/downloads/EXAM3-2.7z">/downloads/EXAM3-2.7z</a></p>
<!-- editor1 結束 --><hr/>
<p><!-- ########################################## --></p>
<p>1.前置步驟與3-1、3-2是一樣的，要先設置好規範好的ipv6</p>
<p>2.將老師的youbot_cart_w10_websocket下載下來</p>
<p>3.將裡面的client、server的.py檔案放至SciTE使用，並將內容中最上面的pip install websocket-client websocket-server keyboard使用cmd下載下來</p>
<p>4.使用cmd進行webot與網頁串聯</p>
<p>5.SciTE中執行client跟server檔，因為youbot中的controller是extern，是指向外部</p>
<p>6.在start.bat檔案中，必須將python路徑設置成set PYTHONPATH=%Disk%:\Python313\DLLs;%Disk%:\Python313\Lib;%Disk%:\Python313\Lib\site-packages;%Disk%:\NX\NXBIN\python;%Disk%:\Webots_2023b\msys64\mingw64\bin;%Disk%</p>
<p>7.python路徑下有一個REM for Webot 其中也得新增webot home<br/>set PYTHON_PATH=%Disk%:\Python313<br/>set WEBOTS_HOME=%Disk%:\Webots_2023b</p>
<p>8.都執行完畢後就可以在localhost上執行，若第一次無法成功可以將webot重新啟動執行串流</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/oH2AYACS8E4" width="560"></iframe></p>
<p>心得:做完這三個EXAM3後，我認為其實並沒有很複雜，但主要是得了解所謂的外部跟內部，以及某些指令的應用，只要知道後，在老師的範例中都能找到資源可以使用</p>
<p><a href="/downloads/EXAM3-3.7z">/downloads/EXAM3-3.7z</a></p>
<h1>Final</h1>
<p><span>期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%)</span></p>
<p><span>題目: <span style="background-color: #ccffcc;">Webots 動態投籃模擬系統的協同設計</span></span></p>
<p><span>說明: </span></p>
<p style="padding-left: 30px;"><span>籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上.</span></p>
<p style="padding-left: 30px;"><span>操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止.</span></p>
<p>請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中.</p>
<p>影片標題: <span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題</span></p>
<p></p>
<p>1.在webot預設資料夾中取得youbot，並借助AI幫助擷取只有車身以及輪子，然後再加入PLATE在youbot上方，但是藉由AI擷取後的bodymesh與wheel是webot_2023b中kuka車之下的InteriorWheel.prote與ExteriorWheel.proto，因此必須於.wbt檔案中進行新增</p>
<p>EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023b/projects/robots/kuka/youbot/protos/BodyMesh.proto"<br/>EXTERNPROTO "../protos/InteriorWheel.proto"<br/>EXTERNPROTO "../protos/ExteriorWheel.proto"</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/iz14FPFwpso" width="560"></iframe></p>
<p></p>
<p>2.接上一步，在PLATE之後放置之前創建好的shooter並套入controller進行控制，能夠使用up down left right操控方向以及j射k收擊球板</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HhELoDrJQGs" width="560"></iframe></p>
<p>3.關於youbot_stand到達第一個座標時會卡住的問題，後續找到是因為<span>InteriorWheel.prote與ExteriorWheel.proto是webot本身預設的，雖然他是.proto檔，但她前身也是一個robot+hingejoint群組，將這之下的motor的maxVelocity預設值14.8更改為100即可<br/></span></p>
<p>HingeJoint {</p>
<p>    device [</p>
<p>      RotationalMotor {</p>
<p>        name IS name</p>
<p>        maxVelocity 100</p>
<p>      }</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bXhhixxTTJo" width="560"></iframe></p>
<p>4.然後加入spervisor跟score_board，遇到的第一個問題為無法使用A鍵生成球，原因是webot下的python沒有安裝numpy，只要在webot中的<span>Python command確認python的位址，隨後在使用</span>python -m pip install numpy就可以了</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lPMKqwMjzRw" width="560"></iframe></p>
<p>5.在supervisor下的feed_ball出現問題，由於我自行建立的youbot一開始是直接使用robot群組下的name做更動，但feed_ball對於生成球的座標是根據youbot改變的，而改變是根據DEF ... Robot，因此儘管不會顯示錯誤，但仍然無法生成球，因此只要在feed_ball下更改我的DEFname以及在.wbt中給robot群組加DEFname就能做動</p>
<p><img alt="" height="548" src="/images/DEFname.png" width="700"/></p>
<p>6.更改<span>ThreeDigitSevenSegment.proto的放置情形，使用score_board supervisor的controller時似乎會無法讀取.proto的內容，儘管.proto內容與在.wbt中使用Transform節點的擺設情形是一致的，但這似乎是設定，需要更改成在.wbt中放置七段顯示器不放置.proto，或是從controll下手更改</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/5dQYh0Xog5k" width="560"></iframe></p>
<p>7.更改完七段顯示器計分後，隨之而來的問題是無法使用supervisor偵測計分，檢查後發現計分上需要用的連動有emitter及receiver，並且他們的<span>channel必須一致才能連動，檢測完後開始投籃發現一直無法計分，但似乎是lookup table出問題，將他更改並改回來後再把youbot_shooter的起始距離往後移動一點即可</span></p>
<p>而本次內容是更改為shooter和stand都由玩家操控，使用B生成球J打擊K收回，controll由info紀錄</p>
<p><span><img alt="" height="296" src="/images/distance.png" width="600"/></span></p>
<p>8.</p>
<p>在自行製作.proto檔案時發現proto檔案無法直接生成，必須得自行建立，尤其是得將"]{" 這兩個括號給分出來分清楚，而以下就是自行建立.proto檔案的起手內容</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#VRML_SIM R2023b utf8

PROTO shooter1 [
  # 場景控制
  field SFVec3f    translation  0 0 0
  field SFRotation rotation     0 0 1 0
] {
  Robot {</pre>
<p>之後導入自己的proto-robot後fourbar_controller無法支援proto檔案，根本原因為proto檔案會省略掉太多子節點，儘管在Scite中檢視也都沒有錯誤，但還是會無法讀取到motor，接著發現不只因為proto檔案無法讀取motor，導入後將proto轉換為bass node後也無法讀取，原因是主要robot為youbot群組，若在下面再加上shooter的robot群組會發生報錯，所以若想將shooter與youbot連動，那麼shooter必須使用solid群組</p>
<p><a href="/downloads/final.7z">/downloads/final.7z</a></p>
<p><a href="/downloads/final-report.pdf">/downloads/final-report.pdf</a></p><h3>info</h3>
<p><img alt="" height="278" src="/images/sensor.png" width="500"/><img alt="" height="349" src="/images/sensor0.2.png" width="300"/></p>
<p>在老師的範本中，是將sensor以圓球形置於球框，並且radius設0.2</p>
<p><img alt="" height="229" src="/images/lookup_table.png" width="300"/></p>
<p>接著是sensor的很重要的一環，lookup table是用來告訴 Webots 模擬器：感測器讀到的值要怎麼對應成實際回傳的數值。</p>
<p>如圖中</p>
<p>1.距離是 0 公尺時，感測器回傳 1000，有1%雜訊</p>
<p>2.距離是0.12公尺時，感測器回傳620，有1%雜訊</p>
<p>依此類推</p>
<p>而下方的type是sensor射線型態，主要是對紅色物體敏感、不會畫出紅點、會忽略透明物體</p>
<p><img alt="" height="212" src="/images/Center of Mass.png" width="500"/></p>
<p>Center of Mass是質心，如果質心太高或偏一邊，在移動或受到力量時，就更容易翻倒</p>
<p>Inertia Matrix慣性矩陣簡單解釋：</p>
<p>它是一個 3x3 的矩陣（數學上叫「張量」），裡面包含了物體繞 x、y、z 三個方向旋轉時的轉動慣量</p>
<p>如果你是圓盤或輪子那種簡單形狀，就只要一個值；但對於複雜 3D 形狀，就需要整個矩陣來描述</p>
<p>| Ixx   0     0  |</p>
<p>|  0   Iyy    0  |</p>
<p>|  0    0   Izz  |</p>
<p>其中：</p>
<p>Ixx 是繞 x 軸的轉動慣量</p>
<p>Iyy 是繞 y 軸的</p>
<p>Izz 是繞 z 軸的</p>
<p>而這數值投球機跟球框是一樣的，因為他們用的youbot是一樣的，輪子就是一樣的</p>
<p><img alt="" height="242" src="/images/ContactProperties1.png" width="500"/><img alt="" height="243" src="/images/ContactProperties2.png" width="500"/></p>
<p>在worldinfo中設置了兩個ContactProperties，其中改動的參數有</p>
<p>coulombFriction：滑動摩擦係數--&gt;值越高，越不容易滑動</p>
<p>frictionRotation：旋轉摩擦（抗扭轉）<span>--&gt;值越高，越難在原地旋轉或扭轉</span></p>
<p>forceDependentSlip：依據力量產生的滑動<span>--&gt;越高：力量大時滑越多</span></p>
<p>Bounce：彈跳 / 回彈係數<span>--&gt;</span><span>值越高，能量損失越少，越好彈回</span></p>
<p><span><img alt="" height="234" src="/images/basictime.png" width="300"/></span></p>
<p>basicTimeStep可以決定每一步模擬代表的「模擬時間長度」，單位是毫秒（ms）。<br/> 就是用來更新所有物理量變化的間隔，所以越小越精細</p>
<p>1.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">DEF youBot_stand Robot {
  translation 6.23 -0.12 0.103
  children [
    BodyMesh {
    }
    DEF WHEEL5 InteriorWheel {
      translation 0.228 -0.158 -0.055
      anchor 0.228 -0.158 -0.055
      name "wheel5"
      sensorName "wheel1sensor"
    }
    DEF WHEEL6 ExteriorWheel {
      translation 0.228 0.158 -0.055
      anchor 0.228 0.158 -0.055
      name "wheel6"
      sensorName "wheel2sensor"
    }
    DEF WHEEL7 ExteriorWheel {
      translation -0.228 -0.158 -0.055
      anchor -0.228 -0.158 -0.055
      name "wheel7"
      sensorName "wheel3sensor"
    }
    DEF WHEEL8 InteriorWheel {
      translation -0.228 0.158 -0.055
      anchor -0.228 0.158 -0.055
      name "wheel8"
      sensorName "wheel4sensor"
    }
    Solid {
      translation 0 0 0.03
      children [
        Pose {
          translation -0.3 0 0.61
          rotation 0 0 1 -1.57
          children [
            CadShape {
              url [
                "../cad/split_parts/basket_stand_small.obj"
              ]
            }
            Pose {
              children [
                DistanceSensor {
                  children [
                    DEF sensor_solid Solid {
                      children [
                        DEF sensor Shape {
                          geometry Sphere {
                            radius 0.2
                          }
                        }
                      ]
                      name "sensor_solid"
                    }
                  ]
                  name "sensor"
                  lookupTable [
                    0 1000 0.01
                    0.12 620 0.01
                    0.13 372 0.01
                    0.14 248 0.01
                    0.15 186 0.01
                    0.18 0 0.01
                  ]
                  type "infra-red"
                  numberOfRays 12
                }
              ]
            }
          ]
        }
        DEF PLATE Shape {
          appearance PBRAppearance {
            baseColor 0.75 0.75 0.75
          }
          geometry Box {
            size 0.5 0.3 0.02
          }
        }
      ]
      name "PLATE"
      boundingObject USE PLATE
      physics Physics {
        mass 0.5
      }
    }
    GPS {
    }
    InertialUnit {
    }
    Emitter {
      name "score_emitter"
      channel 1
    }
  ]
  name "youBot_stand"
  model "KUKA youBot"
  description "KUKA youBot - Base with wheels only"
  boundingObject Group {
    children [
      Pose {
        translation 0 0 -0.045
        children [
          Box {
            size 0.34 0.34 0.09
          }
        ]
      }
      Pose {
        translation 0 0 -0.045
        children [
          Box {
            size 0.56 0.23 0.09
          }
        ]
      }
    ]
  }
  physics Physics {
    density -1
    mass 22
    centerOfMass [
      0 0 -0.045
    ]
    inertiaMatrix [
      0.166204 0.418086 0.55459
      0 0 0
    ]
  }
  controller "stand_controller"
}</pre>
<p></p>
<p>2.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">DEF counter_supervisor Robot {
  children [
    Receiver {
      name "score_receiver"
      channel 1
    }
  ]
  name "counter_supervisor"
  controller "counter_supervisor"
  supervisor TRUE</pre>
<p>以上兩段重要的是emitter及receiver該在的位置<br/><br/></p>
<p></p>
<p>3.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot, Keyboard

# Constants
#TIME_STEP = 32  # Simulation time step in milliseconds
WHEEL_RADIUS = 0.1  # Radius of the wheels in meters (10cm)
L = 0.471  # Half of the robot's length in meters
W = 0.376  # Half of the robot's width in meters
MAX_VELOCITY = 10.0  # Maximum velocity allowed for the wheels

# Initialize the robot
robot = Robot()

# Get simulation time step
timestep = int(robot.getBasicTimeStep())
emitter = robot.getDevice("score_emitter")
score_to_send = 2

# Get the DistanceSensor device
sensor = robot.getDevice('sensor')
sensor.enable(timestep)
score = 0
last_score_time = 0
cooldown = 1.0

# Initialize the keyboard
keyboard = Keyboard()
#keyboard.enable(TIME_STEP)
keyboard.enable(timestep)


# Get motor devices
wheel5 = robot.getDevice("wheel5")  # Front-right wheel
wheel6 = robot.getDevice("wheel6")  # Front-left wheel
wheel7 = robot.getDevice("wheel7")  # Rear-right wheel
wheel8 = robot.getDevice("wheel8")  # Rear-left wheel

# Set motors to velocity control mode
for wheel in [wheel5, wheel6, wheel7, wheel8]:
    wheel.setPosition(float('inf'))  # Enable velocity control
    wheel.setVelocity(0)  # Set initial velocity to 0

def set_wheel_velocity(v1, v2, v3, v4):
    """Set the velocity of all wheels."""
    wheel5.setVelocity(v1)
    wheel6.setVelocity(v2)
    wheel7.setVelocity(v3)
    wheel8.setVelocity(v4)

# lookupTable 轉成程式用的格式
lookup_table = [
    (1000, 0.00),
    (620, 0.12),
    (372, 0.13),
    (248, 0.14),
    (186, 0.15),
    (0, 0.18)
]

def ad_to_distance(ad_value):
    # 假設AD值遞減，距離遞增
    for i in range(len(lookup_table)-1):
        a0, d0 = lookup_table[i]
        a1, d1 = lookup_table[i+1]
        if a1 &lt;= ad_value &lt;= a0:
            # 線性插值
            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)
    # 超出範圍時回傳極值
    if ad_value &gt; lookup_table[0][0]:
        return lookup_table[0][1]
    return lookup_table[-1][1]
    
# Main loop
print("Use 'W', 'A', 'S', 'D' keys to control the robot.")
print("W: Move forward, S: Move backward, A: Turn left, D: Turn right.")
print("Press 'Q' to quit.")

#while robot.step(TIME_STEP) != -1:
while robot.step(timestep) != -1:

    key = keyboard.getKey()  # Read the key pressed
    # Read DistanceSensor value
    sensor_value = sensor.getValue()
    #print(sensor_value)
    distance = ad_to_distance(sensor_value)
    current_time = robot.getTime()
    #print(sensor_value)
    # Check if the ball blocks the sensor (you may need to adjust the threshold based on your sensor's range)
    if key == ord('J') or key == ord('j'):
        print(distance)
    if key == ord('K') or key == ord('k'):
        print(distance)

    if distance &lt; 0.11 and (current_time - last_score_time) &gt; cooldown:
        score +=2
        print("得分")
        print(distance)
        emitter.send(str(score_to_send))
        


    if key == ord('S') or key == ord('s'):
        # Move forward
        velocity = MAX_VELOCITY
        set_wheel_velocity(velocity, velocity, velocity, velocity)
    elif key == ord('W') or key == ord('w'):
        # Move backward
        velocity = -MAX_VELOCITY
        set_wheel_velocity(velocity, velocity, velocity, velocity)
    elif key == ord('D') or key == ord('d'):
        # Turn right
        velocity = MAX_VELOCITY
        set_wheel_velocity(-velocity, velocity, -velocity, velocity)
    elif key == ord('A') or key == ord('a'):
        # Turn left
        velocity = MAX_VELOCITY
        set_wheel_velocity(velocity, -velocity, velocity, -velocity)
    elif key == ord('Q') or key == ord('q'):
        # Quit the program
        print("Exiting...")
        break
    else:
        # Stop the wheels when no key is pressed
        set_wheel_velocity(0, 0, 0, 0)</pre>
<p>4.</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">from controller import Supervisor

SEGMENTS = [
    [1,1,1,1,1,1,0], # 0
    [0,1,1,0,0,0,0], # 1
    [1,1,0,1,1,0,1], # 2
    [1,1,1,1,0,0,1], # 3
    [0,1,1,0,0,1,1], # 4
    [1,0,1,1,0,1,1], # 5
    [1,0,1,1,1,1,1], # 6
    [1,1,1,0,0,0,0], # 7
    [1,1,1,1,1,1,1], # 8
    [1,1,1,1,0,1,1], # 9
]
DIGIT_MATERIALS = [
    ['a3mat', 'b3mat', 'c3mat', 'd3mat', 'e3mat', 'f3mat', 'g3mat'], # 百
    ['a2mat', 'b2mat', 'c2mat', 'd2mat', 'e2mat', 'f2mat', 'g2mat'], # 十
    ['a1mat', 'b1mat', 'c1mat', 'd1mat', 'e1mat', 'f1mat', 'g1mat'], # 個
]
ON_COLOR = [0, 1, 0]
OFF_COLOR = [0.05, 0.05, 0.05]

def set_digit(supervisor, digit_index, value):
    segs = SEGMENTS[value]
    for i, seg_on in enumerate(segs):
        mat_node = supervisor.getFromDef(DIGIT_MATERIALS[digit_index][i])
        if mat_node:
            mat_node.getField('diffuseColor').setSFColor(ON_COLOR if seg_on else OFF_COLOR)
        else:
            print(f"找不到 {DIGIT_MATERIALS[digit_index][i]} 這個DEF")

def set_display(supervisor, value):
    value = max(0, min(999, int(value)))
    h = value // 100
    t = (value // 10) % 10
    u = value % 10
    set_digit(supervisor, 0, h)
    set_digit(supervisor, 1, t)
    set_digit(supervisor, 2, u)

supervisor = Supervisor()
timestep = int(supervisor.getBasicTimeStep())

score = 0
receiver = supervisor.getDevice("score_receiver")
receiver.enable(timestep)

while supervisor.step(timestep) != -1:
    while receiver.getQueueLength() &gt; 0:
        data = receiver.getString()
        if data.isdigit():
            try:
                received_score = int(data)
                score += received_score
                print(f"收到得分訊息: +{received_score}, 總分: {score}")
            except Exception as e:
                print("訊息格式錯誤:", e)
        receiver.nextPacket()
    set_display(supervisor, score)</pre>
<p>以上兩段重要的連動在於</p>
<div>
<div><span>timestep</span><span> </span><span>=</span><span> </span><span>int</span><span>(</span><span>robot</span><span>.getBasicTimeStep())</span></div>
<div><span>emitter</span><span> </span><span>=</span><span> </span><span>robot</span><span>.getDevice(</span><span>"score_emitter"</span><span>)</span></div>
<div><span>score_to_send</span><span> </span><span>=</span><span> </span><span>2<br/></span></div>
<div><span> </span></div>
<div>
<div>
<div><span>if</span><span> </span><span>distance</span><span> </span><span>&lt;</span><span> </span><span>0.11</span><span> </span><span>and</span><span> (</span><span>current_time</span><span> </span><span>-</span><span> </span><span>last_score_time</span><span>) </span><span>&gt;</span><span> </span><span>cooldown</span><span>:</span></div>
<div><span>        </span><span>score</span><span> </span><span>+=</span><span>2</span></div>
<div><span>        </span><span>print</span><span>(</span><span>"得分"</span><span>)</span></div>
<div><span>        </span><span>print</span><span>(</span><span>distance</span><span>)</span></div>
<div><span>        </span><span>emitter</span><span>.send(</span><span>str</span><span>(</span><span>score_to_send</span><span>))</span></div>
<div><span></span></div>
<div><span>以及</span></div>
<div><span></span></div>
</div>
</div>
<div>
<div>
<div><span>while</span><span> </span><span>supervisor</span><span>.step(</span><span>timestep</span><span>) </span><span>!=</span><span> </span><span>-</span><span>1</span><span>:</span></div>
<div><span>    </span><span>while</span><span> </span><span>receiver</span><span>.getQueueLength() </span><span>&gt;</span><span> </span><span>0</span><span>:</span></div>
<div><span>        </span><span>data</span><span> </span><span>=</span><span> </span><span>receiver</span><span>.getString()</span></div>
<div><span>        </span><span>if</span><span> </span><span>data</span><span>.isdigit():</span></div>
<div><span>            </span><span>try</span><span>:</span></div>
<div><span>                </span><span>received_score</span><span> </span><span>=</span><span> </span><span>int</span><span>(</span><span>data</span><span>)</span></div>
<div><span>                </span><span>score</span><span> </span><span>+=</span><span> </span><span>received_score</span></div>
<div><span>                </span><span>print</span><span>(</span><span>f</span><span>"收到得分訊息: +</span><span>{</span><span>received_score</span><span>}</span><span>, 總分: </span><span>{</span><span>score</span><span>}</span><span>"</span><span>)</span></div>
<div><span>            </span><span>except</span><span> </span><span>Exception</span><span> </span><span>as</span><span> </span><span>e</span><span>:</span></div>
<div><span>                </span><span>print</span><span>(</span><span>"訊息格式錯誤:"</span><span>, </span><span>e</span><span>)</span></div>
<div><span>        </span><span>receiver</span><span>.nextPacket()</span></div>
<div><span>    </span><span>set_display</span><span>(</span><span>supervisor</span><span>, </span><span>score</span><span>)</span></div>
</div>
</div>
</div>
<p></p>
<h1>Brython</h1>
<p><button id="add1to100">1 add to 100</button></p>
<p><!-- 導入 brython 程式庫 --></p>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<p><!-- 啟動 Brython --></p>
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<p><!-- editor1 開始 --></p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<p><!-- editor1 結束 --></p>
<hr/>
<p><!-- ########################################## --></p>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<p><!-- editor2 開始 --></p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<p><!-- editor2 結束 --></p>
<hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>
<p>&gt;</p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<p><!-- editor2 結束 --></p>
<hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>